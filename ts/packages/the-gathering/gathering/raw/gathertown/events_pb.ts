// @generated by protoc-gen-es v1.3.3 with parameter "target=ts"
// @generated from file gathering/raw/gathertown/events.proto (package gathertown, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * common type for all deprecated message data, so that the $case is decoded but not the data
 *
 * @generated from message gathertown.Deprecated
 */
export class Deprecated extends Message<Deprecated> {
  constructor(data?: PartialMessage<Deprecated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Deprecated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Deprecated {
    return new Deprecated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Deprecated {
    return new Deprecated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Deprecated {
    return new Deprecated().fromJsonString(jsonString, options);
  }

  static equals(a: Deprecated | PlainMessage<Deprecated> | undefined, b: Deprecated | PlainMessage<Deprecated> | undefined): boolean {
    return proto3.util.equals(Deprecated, a, b);
  }
}

/**
 * @generated from message gathertown.SpriteDirectionEnum
 */
export class SpriteDirectionEnum extends Message<SpriteDirectionEnum> {
  constructor(data?: PartialMessage<SpriteDirectionEnum>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpriteDirectionEnum";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpriteDirectionEnum {
    return new SpriteDirectionEnum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpriteDirectionEnum {
    return new SpriteDirectionEnum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpriteDirectionEnum {
    return new SpriteDirectionEnum().fromJsonString(jsonString, options);
  }

  static equals(a: SpriteDirectionEnum | PlainMessage<SpriteDirectionEnum> | undefined, b: SpriteDirectionEnum | PlainMessage<SpriteDirectionEnum> | undefined): boolean {
    return proto3.util.equals(SpriteDirectionEnum, a, b);
  }
}

/**
 * @generated from enum gathertown.SpriteDirectionEnum.ENUM
 */
export enum SpriteDirectionEnum_ENUM {
  /**
   * @generated from enum value: Stand = 0;
   */
  Stand = 0,

  /**
   * @generated from enum value: Down = 1;
   */
  Down = 1,

  /**
   * @generated from enum value: DownAlt = 2;
   */
  DownAlt = 2,

  /**
   * @generated from enum value: Up = 3;
   */
  Up = 3,

  /**
   * @generated from enum value: UpAlt = 4;
   */
  UpAlt = 4,

  /**
   * @generated from enum value: Left = 5;
   */
  Left = 5,

  /**
   * @generated from enum value: LeftAlt = 6;
   */
  LeftAlt = 6,

  /**
   * @generated from enum value: Right = 7;
   */
  Right = 7,

  /**
   * @generated from enum value: RightAlt = 8;
   */
  RightAlt = 8,

  /**
   * @generated from enum value: Dance1 = 9;
   */
  Dance1 = 9,

  /**
   * @generated from enum value: Dance2 = 10;
   */
  Dance2 = 10,

  /**
   * @generated from enum value: Dance3 = 11;
   */
  Dance3 = 11,

  /**
   * @generated from enum value: Dance4 = 12;
   */
  Dance4 = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(SpriteDirectionEnum_ENUM)
proto3.util.setEnumType(SpriteDirectionEnum_ENUM, "gathertown.SpriteDirectionEnum.ENUM", [
  { no: 0, name: "Stand" },
  { no: 1, name: "Down" },
  { no: 2, name: "DownAlt" },
  { no: 3, name: "Up" },
  { no: 4, name: "UpAlt" },
  { no: 5, name: "Left" },
  { no: 6, name: "LeftAlt" },
  { no: 7, name: "Right" },
  { no: 8, name: "RightAlt" },
  { no: 9, name: "Dance1" },
  { no: 10, name: "Dance2" },
  { no: 11, name: "Dance3" },
  { no: 12, name: "Dance4" },
]);

/**
 * @generated from message gathertown.MoveDirectionEnum
 */
export class MoveDirectionEnum extends Message<MoveDirectionEnum> {
  constructor(data?: PartialMessage<MoveDirectionEnum>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MoveDirectionEnum";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MoveDirectionEnum {
    return new MoveDirectionEnum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MoveDirectionEnum {
    return new MoveDirectionEnum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MoveDirectionEnum {
    return new MoveDirectionEnum().fromJsonString(jsonString, options);
  }

  static equals(a: MoveDirectionEnum | PlainMessage<MoveDirectionEnum> | undefined, b: MoveDirectionEnum | PlainMessage<MoveDirectionEnum> | undefined): boolean {
    return proto3.util.equals(MoveDirectionEnum, a, b);
  }
}

/**
 * @generated from enum gathertown.MoveDirectionEnum.ENUM
 */
export enum MoveDirectionEnum_ENUM {
  /**
   * @generated from enum value: Left = 0;
   */
  Left = 0,

  /**
   * @generated from enum value: Right = 1;
   */
  Right = 1,

  /**
   * @generated from enum value: Up = 2;
   */
  Up = 2,

  /**
   * @generated from enum value: Down = 3;
   */
  Down = 3,

  /**
   * @generated from enum value: Dance = 4;
   */
  Dance = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(MoveDirectionEnum_ENUM)
proto3.util.setEnumType(MoveDirectionEnum_ENUM, "gathertown.MoveDirectionEnum.ENUM", [
  { no: 0, name: "Left" },
  { no: 1, name: "Right" },
  { no: 2, name: "Up" },
  { no: 3, name: "Down" },
  { no: 4, name: "Dance" },
]);

/**
 * @generated from message gathertown.InteractionEnum
 */
export class InteractionEnum extends Message<InteractionEnum> {
  constructor(data?: PartialMessage<InteractionEnum>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.InteractionEnum";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InteractionEnum {
    return new InteractionEnum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InteractionEnum {
    return new InteractionEnum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InteractionEnum {
    return new InteractionEnum().fromJsonString(jsonString, options);
  }

  static equals(a: InteractionEnum | PlainMessage<InteractionEnum> | undefined, b: InteractionEnum | PlainMessage<InteractionEnum> | undefined): boolean {
    return proto3.util.equals(InteractionEnum, a, b);
  }
}

/**
 * @generated from enum gathertown.InteractionEnum.ENUM
 */
export enum InteractionEnum_ENUM {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: EMBEDDED_WEBSITE = 1;
   */
  EMBEDDED_WEBSITE = 1,

  /**
   * @generated from enum value: POSTER = 2;
   */
  POSTER = 2,

  /**
   * @generated from enum value: VIDEO = 3;
   */
  VIDEO = 3,

  /**
   * @generated from enum value: EXTERNAL_CALL = 4;
   */
  EXTERNAL_CALL = 4,

  /**
   * @generated from enum value: EXTENSION = 5;
   */
  EXTENSION = 5,

  /**
   * @generated from enum value: NOTE = 6;
   */
  NOTE = 6,

  /**
   * @generated from enum value: MODAL_EXTENSION = 7;
   */
  MODAL_EXTENSION = 7,

  /**
   * @generated from enum value: COMPONENT_MODAL = 8;
   */
  COMPONENT_MODAL = 8,

  /**
   * @generated from enum value: SIDE_PANEL_TRIGGER = 9;
   */
  SIDE_PANEL_TRIGGER = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(InteractionEnum_ENUM)
proto3.util.setEnumType(InteractionEnum_ENUM, "gathertown.InteractionEnum.ENUM", [
  { no: 0, name: "NONE" },
  { no: 1, name: "EMBEDDED_WEBSITE" },
  { no: 2, name: "POSTER" },
  { no: 3, name: "VIDEO" },
  { no: 4, name: "EXTERNAL_CALL" },
  { no: 5, name: "EXTENSION" },
  { no: 6, name: "NOTE" },
  { no: 7, name: "MODAL_EXTENSION" },
  { no: 8, name: "COMPONENT_MODAL" },
  { no: 9, name: "SIDE_PANEL_TRIGGER" },
]);

/**
 * @generated from message gathertown.PlayerInitInfo
 */
export class PlayerInitInfo extends Message<PlayerInitInfo> {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * @generated from field: optional uint32 x = 3;
   */
  x?: number;

  /**
   * @generated from field: optional uint32 y = 4;
   */
  y?: number;

  /**
   * @generated from field: optional string map = 5;
   */
  map?: string;

  /**
   * @generated from field: optional string affiliation = 6;
   */
  affiliation?: string;

  /**
   * @generated from field: optional bool busy = 7;
   */
  busy?: boolean;

  /**
   * @generated from field: optional string textStatus = 8;
   */
  textStatus?: string;

  /**
   * @generated from field: optional string emojiStatus = 9;
   */
  emojiStatus?: string;

  /**
   * @generated from field: optional gathertown.DBOutfit currentlyEquippedWearables = 10;
   */
  currentlyEquippedWearables?: DBOutfit;

  /**
   * @generated from field: optional string focusModeEndTime = 11;
   */
  focusModeEndTime?: string;

  /**
   * @generated from field: optional string itemString = 14;
   */
  itemString?: string;

  /**
   * @generated from field: optional bool isNpc = 15;
   */
  isNpc?: boolean;

  constructor(data?: PartialMessage<PlayerInitInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerInitInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 4, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 5, name: "map", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "affiliation", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "busy", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 8, name: "textStatus", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "emojiStatus", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "currentlyEquippedWearables", kind: "message", T: DBOutfit, opt: true },
    { no: 11, name: "focusModeEndTime", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 14, name: "itemString", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 15, name: "isNpc", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerInitInfo {
    return new PlayerInitInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerInitInfo {
    return new PlayerInitInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerInitInfo {
    return new PlayerInitInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerInitInfo | PlainMessage<PlayerInitInfo> | undefined, b: PlayerInitInfo | PlainMessage<PlayerInitInfo> | undefined): boolean {
    return proto3.util.equals(PlayerInitInfo, a, b);
  }
}

/**
 * @generated from message gathertown.DBOutfit
 */
export class DBOutfit extends Message<DBOutfit> {
  /**
   * @generated from field: string skin = 1;
   */
  skin = "";

  /**
   * @generated from field: string hair = 2;
   */
  hair = "";

  /**
   * @generated from field: string facial_hair = 3;
   */
  facialHair = "";

  /**
   * @generated from field: string top = 4;
   */
  top = "";

  /**
   * @generated from field: string bottom = 5;
   */
  bottom = "";

  /**
   * @generated from field: string shoes = 6;
   */
  shoes = "";

  /**
   * @generated from field: string hat = 7;
   */
  hat = "";

  /**
   * @generated from field: string glasses = 8;
   */
  glasses = "";

  /**
   * @generated from field: string other = 9;
   */
  other = "";

  /**
   * @generated from field: optional string costume = 10;
   */
  costume?: string;

  /**
   * @generated from field: optional string mobility = 11;
   */
  mobility?: string;

  /**
   * @generated from field: optional string jacket = 12;
   */
  jacket?: string;

  constructor(data?: PartialMessage<DBOutfit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.DBOutfit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "skin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "facial_hair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "top", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "bottom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "shoes", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "hat", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "glasses", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "other", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "costume", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "mobility", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "jacket", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DBOutfit {
    return new DBOutfit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DBOutfit {
    return new DBOutfit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DBOutfit {
    return new DBOutfit().fromJsonString(jsonString, options);
  }

  static equals(a: DBOutfit | PlainMessage<DBOutfit> | undefined, b: DBOutfit | PlainMessage<DBOutfit> | undefined): boolean {
    return proto3.util.equals(DBOutfit, a, b);
  }
}

/**
 * Defines how to slice an incoming animation spritesheet
 *
 * @generated from message gathertown.WireObjectSpritesheetFraming
 */
export class WireObjectSpritesheetFraming extends Message<WireObjectSpritesheetFraming> {
  /**
   * @generated from field: int32 frameWidth = 1;
   */
  frameWidth = 0;

  /**
   * @generated from field: int32 frameHeight = 2;
   */
  frameHeight = 0;

  constructor(data?: PartialMessage<WireObjectSpritesheetFraming>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.WireObjectSpritesheetFraming";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "frameWidth", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "frameHeight", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WireObjectSpritesheetFraming {
    return new WireObjectSpritesheetFraming().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WireObjectSpritesheetFraming {
    return new WireObjectSpritesheetFraming().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WireObjectSpritesheetFraming {
    return new WireObjectSpritesheetFraming().fromJsonString(jsonString, options);
  }

  static equals(a: WireObjectSpritesheetFraming | PlainMessage<WireObjectSpritesheetFraming> | undefined, b: WireObjectSpritesheetFraming | PlainMessage<WireObjectSpritesheetFraming> | undefined): boolean {
    return proto3.util.equals(WireObjectSpritesheetFraming, a, b);
  }
}

/**
 * Defines an Spritesheet referencing frames from the split spritesheet
 *
 * @generated from message gathertown.WireObjectSpriteAnimConfig
 */
export class WireObjectSpriteAnimConfig extends Message<WireObjectSpriteAnimConfig> {
  /**
   *
   * Defines how to interpret the `sequence `field. If `true`, `sequence` is interpreted as a set of
   * animation key frames which are interpolated between for the animation.
   * For example, `sequence: [0,10], useSequenceAsRange: true` would mean the animation spans frames
   * 0 _through_ 10 (inclusive). Use this when your animation uses sequential frames.
   *
   * Default: `false`
   *
   * @generated from field: optional bool useSequenceAsRange = 1;
   */
  useSequenceAsRange?: boolean;

  /**
   * *
   * Defines which spritesheet frames make up this animation.
   *
   * **By default,** `sequence` should be an array of arbitrary frame numbers defining this animation.
   *   ex: [4,5,4,5,4,6,6,6] animates between frames 4, 5, and 6 - but not necessarily in sequential order.
   *
   * **When `useSequenceAsRange` is `true`,** this should be set to two integers defining the **start** and **end** caps.
   *   ex: [0, 10] means this animation starts on frame 0 and ends on frame 10 (inclusive).
   *       (This is equivalent to setting sequence to `[0, 1, 2, ...]`)
   *
   * @generated from field: repeated uint32 sequence = 2;
   */
  sequence: number[] = [];

  /**
   * Does this animation repeat or should it stop on the last frame? (Default: false)
   *
   * @generated from field: optional bool loop = 3;
   */
  loop?: boolean;

  /**
   * Frames per second this animation should display.
   *
   * @generated from field: uint32 frameRate = 4;
   */
  frameRate = 0;

  constructor(data?: PartialMessage<WireObjectSpriteAnimConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.WireObjectSpriteAnimConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "useSequenceAsRange", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "sequence", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 3, name: "loop", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "frameRate", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WireObjectSpriteAnimConfig {
    return new WireObjectSpriteAnimConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WireObjectSpriteAnimConfig {
    return new WireObjectSpriteAnimConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WireObjectSpriteAnimConfig {
    return new WireObjectSpriteAnimConfig().fromJsonString(jsonString, options);
  }

  static equals(a: WireObjectSpriteAnimConfig | PlainMessage<WireObjectSpriteAnimConfig> | undefined, b: WireObjectSpriteAnimConfig | PlainMessage<WireObjectSpriteAnimConfig> | undefined): boolean {
    return proto3.util.equals(WireObjectSpriteAnimConfig, a, b);
  }
}

/**
 * Animated objects need to declare their spritesheet, how to slice it, and the different Spritesheets
 * provided by the given spritesheet.
 *
 * @generated from message gathertown.WireObjectSpritesheet
 */
export class WireObjectSpritesheet extends Message<WireObjectSpritesheet> {
  /**
   * @generated from field: string spritesheetUrl = 1;
   */
  spritesheetUrl = "";

  /**
   * @generated from field: gathertown.WireObjectSpritesheetFraming framing = 2;
   */
  framing?: WireObjectSpritesheetFraming;

  /**
   * @generated from field: map<string, gathertown.WireObjectSpriteAnimConfig> animations = 3;
   */
  animations: { [key: string]: WireObjectSpriteAnimConfig } = {};

  /**
   * @generated from field: optional string currentAnim = 4;
   */
  currentAnim?: string;

  /**
   * @generated from field: optional bool pauseAnimationsIfFpsBelowFramerate = 5;
   */
  pauseAnimationsIfFpsBelowFramerate?: boolean;

  constructor(data?: PartialMessage<WireObjectSpritesheet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.WireObjectSpritesheet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spritesheetUrl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "framing", kind: "message", T: WireObjectSpritesheetFraming },
    { no: 3, name: "animations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: WireObjectSpriteAnimConfig} },
    { no: 4, name: "currentAnim", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "pauseAnimationsIfFpsBelowFramerate", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WireObjectSpritesheet {
    return new WireObjectSpritesheet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WireObjectSpritesheet {
    return new WireObjectSpritesheet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WireObjectSpritesheet {
    return new WireObjectSpritesheet().fromJsonString(jsonString, options);
  }

  static equals(a: WireObjectSpritesheet | PlainMessage<WireObjectSpritesheet> | undefined, b: WireObjectSpritesheet | PlainMessage<WireObjectSpritesheet> | undefined): boolean {
    return proto3.util.equals(WireObjectSpritesheet, a, b);
  }
}

/**
 * @generated from message gathertown.WireObject
 */
export class WireObject extends Message<WireObject> {
  /**
   * @generated from field: optional string templateId = 1;
   */
  templateId?: string;

  /**
   * @generated from field: optional string _name = 2;
   */
  Name?: string;

  /**
   * repeated is inherently optional
   *
   * @generated from field: repeated string _tags = 3;
   */
  Tags: string[] = [];

  /**
   * @generated from field: optional uint32 x = 4;
   */
  x?: number;

  /**
   * @generated from field: optional uint32 y = 5;
   */
  y?: number;

  /**
   * @generated from field: optional float offsetX = 6;
   */
  offsetX?: number;

  /**
   * @generated from field: optional float offsetY = 7;
   */
  offsetY?: number;

  /**
   * @generated from field: optional string color = 8;
   */
  color?: string;

  /**
   * @generated from field: optional uint32 orientation = 9;
   */
  orientation?: number;

  /**
   * @generated from field: optional string normal = 10;
   */
  normal?: string;

  /**
   * @generated from field: optional string highlighted = 11;
   */
  highlighted?: string;

  /**
   * @generated from field: optional gathertown.InteractionEnum.ENUM type = 12;
   */
  type?: InteractionEnum_ENUM;

  /**
   * deprecating hopefully?
   *
   * @generated from field: optional uint32 width = 13;
   */
  width?: number;

  /**
   * deprecating hopefully?
   *
   * @generated from field: optional uint32 height = 14;
   */
  height?: number;

  /**
   * useful to tag an object with which extension should pay attention to it
   *
   * @generated from field: optional string extensionClass = 15;
   */
  extensionClass?: string;

  /**
   * Any custom value of `previewMessage` will be shown as is, not localized
   *
   * @generated from field: optional string previewMessage = 16;
   */
  previewMessage?: string;

  /**
   * @generated from field: optional uint32 distThreshold = 17;
   */
  distThreshold?: number;

  /**
   * @generated from field: optional string propertiesJson = 18;
   */
  propertiesJson?: string;

  /**
   * @generated from field: optional gathertown.Sound sound = 19;
   */
  sound?: Sound;

  /**
   * deprecated on the product side
   *
   * @generated from field: optional gathertown.ObjectTime objectStartTime = 20;
   */
  objectStartTime?: ObjectTime;

  /**
   * deprecated on the product side
   *
   * @generated from field: optional gathertown.ObjectTime objectExpireTime = 21;
   */
  objectExpireTime?: ObjectTime;

  /**
   * @generated from field: optional string id = 22;
   */
  id?: string;

  /**
   * @generated from field: optional string customState = 23;
   */
  customState?: string;

  /**
   * @generated from field: optional string objectPlacerId = 24;
   */
  objectPlacerId?: string;

  /**
   * experimental - this should have been in customState :/
   *
   * @generated from field: optional uint32 numGoKarts = 25;
   */
  numGoKarts?: number;

  /**
   * @generated from field: optional gathertown.WireObjectSpritesheet spritesheet = 26;
   */
  spritesheet?: WireObjectSpritesheet;

  /**
   * @generated from field: optional float zIndex = 27;
   */
  zIndex?: number;

  constructor(data?: PartialMessage<WireObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.WireObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "templateId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "_tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 5, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "offsetX", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 7, name: "offsetY", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 8, name: "color", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "orientation", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 10, name: "normal", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "highlighted", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "type", kind: "enum", T: proto3.getEnumType(InteractionEnum_ENUM), opt: true },
    { no: 13, name: "width", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 14, name: "height", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 15, name: "extensionClass", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 16, name: "previewMessage", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 17, name: "distThreshold", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 18, name: "propertiesJson", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 19, name: "sound", kind: "message", T: Sound, opt: true },
    { no: 20, name: "objectStartTime", kind: "message", T: ObjectTime, opt: true },
    { no: 21, name: "objectExpireTime", kind: "message", T: ObjectTime, opt: true },
    { no: 22, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 23, name: "customState", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 24, name: "objectPlacerId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 25, name: "numGoKarts", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 26, name: "spritesheet", kind: "message", T: WireObjectSpritesheet, opt: true },
    { no: 27, name: "zIndex", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WireObject {
    return new WireObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WireObject {
    return new WireObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WireObject {
    return new WireObject().fromJsonString(jsonString, options);
  }

  static equals(a: WireObject | PlainMessage<WireObject> | undefined, b: WireObject | PlainMessage<WireObject> | undefined): boolean {
    return proto3.util.equals(WireObject, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceMemberInfo
 */
export class SpaceMemberInfo extends Message<SpaceMemberInfo> {
  /**
   * roles should be { [role in CoreRole]: boolean }, but we can't do string enums in protobuf
   *
   * deprecating
   *
   * @generated from field: map<string, bool> roles = 1;
   */
  roles: { [key: string]: boolean } = {};

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * @generated from field: optional gathertown.DBOutfit currentlyEquippedWearables = 4;
   */
  currentlyEquippedWearables?: DBOutfit;

  /**
   * @generated from field: optional bool allowScreenPointer = 6;
   */
  allowScreenPointer?: boolean;

  /**
   * role should be CoreRole, but we can't do string enums in protobuf
   *
   * @generated from field: string role = 7;
   */
  role = "";

  constructor(data?: PartialMessage<SpaceMemberInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceMemberInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "roles", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 8 /* ScalarType.BOOL */} },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "currentlyEquippedWearables", kind: "message", T: DBOutfit, opt: true },
    { no: 6, name: "allowScreenPointer", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceMemberInfo {
    return new SpaceMemberInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceMemberInfo {
    return new SpaceMemberInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceMemberInfo {
    return new SpaceMemberInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceMemberInfo | PlainMessage<SpaceMemberInfo> | undefined, b: SpaceMemberInfo | PlainMessage<SpaceMemberInfo> | undefined): boolean {
    return proto3.util.equals(SpaceMemberInfo, a, b);
  }
}

/**
 * @generated from message gathertown.BackedUpDeskObject
 */
export class BackedUpDeskObject extends Message<BackedUpDeskObject> {
  /**
   * @generated from field: gathertown.WireObject obj = 1;
   */
  obj?: WireObject;

  /**
   * @generated from field: uint32 offsetX = 2;
   */
  offsetX = 0;

  /**
   * @generated from field: uint32 offsetY = 3;
   */
  offsetY = 0;

  constructor(data?: PartialMessage<BackedUpDeskObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.BackedUpDeskObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "obj", kind: "message", T: WireObject },
    { no: 2, name: "offsetX", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "offsetY", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BackedUpDeskObject {
    return new BackedUpDeskObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BackedUpDeskObject {
    return new BackedUpDeskObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BackedUpDeskObject {
    return new BackedUpDeskObject().fromJsonString(jsonString, options);
  }

  static equals(a: BackedUpDeskObject | PlainMessage<BackedUpDeskObject> | undefined, b: BackedUpDeskObject | PlainMessage<BackedUpDeskObject> | undefined): boolean {
    return proto3.util.equals(BackedUpDeskObject, a, b);
  }
}

/**
 * @generated from message gathertown.DeskObjects
 */
export class DeskObjects extends Message<DeskObjects> {
  /**
   * @generated from field: map<string, gathertown.BackedUpDeskObject> objects = 1;
   */
  objects: { [key: string]: BackedUpDeskObject } = {};

  constructor(data?: PartialMessage<DeskObjects>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.DeskObjects";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objects", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: BackedUpDeskObject} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeskObjects {
    return new DeskObjects().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeskObjects {
    return new DeskObjects().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeskObjects {
    return new DeskObjects().fromJsonString(jsonString, options);
  }

  static equals(a: DeskObjects | PlainMessage<DeskObjects> | undefined, b: DeskObjects | PlainMessage<DeskObjects> | undefined): boolean {
    return proto3.util.equals(DeskObjects, a, b);
  }
}

/**
 * @generated from message gathertown.DeskInfoV2
 */
export class DeskInfoV2 extends Message<DeskInfoV2> {
  /**
   * @generated from field: optional string deskId = 1;
   */
  deskId?: string;

  /**
   * @generated from field: optional string description = 2;
   */
  description?: string;

  /**
   * @generated from field: optional bool locked = 3;
   */
  locked?: boolean;

  /**
   * this isn't up to date with what's actually on/around someone's desk, it just exists as a way to back up and restore those objects while they're switching desks
   *
   * @generated from field: optional gathertown.DeskObjects lastDeskObjects = 4;
   */
  lastDeskObjects?: DeskObjects;

  /**
   * @generated from field: optional string mapId = 5;
   */
  mapId?: string;

  constructor(data?: PartialMessage<DeskInfoV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.DeskInfoV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deskId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "locked", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "lastDeskObjects", kind: "message", T: DeskObjects, opt: true },
    { no: 5, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeskInfoV2 {
    return new DeskInfoV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeskInfoV2 {
    return new DeskInfoV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeskInfoV2 {
    return new DeskInfoV2().fromJsonString(jsonString, options);
  }

  static equals(a: DeskInfoV2 | PlainMessage<DeskInfoV2> | undefined, b: DeskInfoV2 | PlainMessage<DeskInfoV2> | undefined): boolean {
    return proto3.util.equals(DeskInfoV2, a, b);
  }
}

/**
 * @generated from message gathertown.MapAndDesk
 */
export class MapAndDesk extends Message<MapAndDesk> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string deskId = 2;
   */
  deskId = "";

  constructor(data?: PartialMessage<MapAndDesk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapAndDesk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deskId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapAndDesk {
    return new MapAndDesk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapAndDesk {
    return new MapAndDesk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapAndDesk {
    return new MapAndDesk().fromJsonString(jsonString, options);
  }

  static equals(a: MapAndDesk | PlainMessage<MapAndDesk> | undefined, b: MapAndDesk | PlainMessage<MapAndDesk> | undefined): boolean {
    return proto3.util.equals(MapAndDesk, a, b);
  }
}

/**
 * @generated from message gathertown.Sound
 */
export class Sound extends Message<Sound> {
  /**
   * @generated from field: string src = 1;
   */
  src = "";

  /**
   * @generated from field: float volume = 2;
   */
  volume = 0;

  /**
   * @generated from field: bool loop = 3;
   */
  loop = false;

  /**
   * @generated from field: uint32 maxDistance = 4;
   */
  maxDistance = 0;

  /**
   * @generated from field: optional bool isPositional = 5;
   */
  isPositional?: boolean;

  /**
   * @generated from field: optional bool stream = 6;
   */
  stream?: boolean;

  constructor(data?: PartialMessage<Sound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Sound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "src", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "volume", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "loop", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "maxDistance", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "isPositional", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "stream", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sound {
    return new Sound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sound {
    return new Sound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sound {
    return new Sound().fromJsonString(jsonString, options);
  }

  static equals(a: Sound | PlainMessage<Sound> | undefined, b: Sound | PlainMessage<Sound> | undefined): boolean {
    return proto3.util.equals(Sound, a, b);
  }
}

/**
 * Can be deprecated?
 *
 * @generated from message gathertown.ObjectTime
 */
export class ObjectTime extends Message<ObjectTime> {
  /**
   * @generated from field: uint32 _seconds = 1;
   */
  Seconds = 0;

  /**
   * @generated from field: optional string _timezone = 2;
   */
  Timezone?: string;

  constructor(data?: PartialMessage<ObjectTime>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ObjectTime";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "_timezone", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObjectTime {
    return new ObjectTime().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObjectTime {
    return new ObjectTime().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObjectTime {
    return new ObjectTime().fromJsonString(jsonString, options);
  }

  static equals(a: ObjectTime | PlainMessage<ObjectTime> | undefined, b: ObjectTime | PlainMessage<ObjectTime> | undefined): boolean {
    return proto3.util.equals(ObjectTime, a, b);
  }
}

/**
 * @generated from message gathertown.Space
 */
export class Space extends Message<Space> {
  /**
   * @generated from field: string spaceId = 1;
   */
  spaceId = "";

  /**
   * @generated from field: uint32 x = 2;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 3;
   */
  y = 0;

  /**
   * @generated from field: optional bool colored = 4;
   */
  colored?: boolean;

  constructor(data?: PartialMessage<Space>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Space";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spaceId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "colored", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Space {
    return new Space().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Space {
    return new Space().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Space {
    return new Space().fromJsonString(jsonString, options);
  }

  static equals(a: Space | PlainMessage<Space> | undefined, b: Space | PlainMessage<Space> | undefined): boolean {
    return proto3.util.equals(Space, a, b);
  }
}

/**
 * @generated from message gathertown.NookCoords
 */
export class NookCoords extends Message<NookCoords> {
  /**
   * @generated from field: repeated gathertown.WirePoint coords = 1;
   */
  coords: WirePoint[] = [];

  constructor(data?: PartialMessage<NookCoords>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.NookCoords";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "coords", kind: "message", T: WirePoint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NookCoords {
    return new NookCoords().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NookCoords {
    return new NookCoords().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NookCoords {
    return new NookCoords().fromJsonString(jsonString, options);
  }

  static equals(a: NookCoords | PlainMessage<NookCoords> | undefined, b: NookCoords | PlainMessage<NookCoords> | undefined): boolean {
    return proto3.util.equals(NookCoords, a, b);
  }
}

/**
 * @generated from message gathertown.AllowedUsers
 */
export class AllowedUsers extends Message<AllowedUsers> {
  /**
   * @generated from field: repeated string users = 1;
   */
  users: string[] = [];

  constructor(data?: PartialMessage<AllowedUsers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.AllowedUsers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllowedUsers {
    return new AllowedUsers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllowedUsers {
    return new AllowedUsers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllowedUsers {
    return new AllowedUsers().fromJsonString(jsonString, options);
  }

  static equals(a: AllowedUsers | PlainMessage<AllowedUsers> | undefined, b: AllowedUsers | PlainMessage<AllowedUsers> | undefined): boolean {
    return proto3.util.equals(AllowedUsers, a, b);
  }
}

/**
 * @generated from message gathertown.RequestUser
 */
export class RequestUser extends Message<RequestUser> {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  constructor(data?: PartialMessage<RequestUser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RequestUser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestUser {
    return new RequestUser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestUser {
    return new RequestUser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestUser {
    return new RequestUser().fromJsonString(jsonString, options);
  }

  static equals(a: RequestUser | PlainMessage<RequestUser> | undefined, b: RequestUser | PlainMessage<RequestUser> | undefined): boolean {
    return proto3.util.equals(RequestUser, a, b);
  }
}

/**
 * @generated from message gathertown.RequestedUsers
 */
export class RequestedUsers extends Message<RequestedUsers> {
  /**
   * maps uid to optional player metadata about users who requested to join
   *
   * @generated from field: map<string, gathertown.RequestUser> users = 1;
   */
  users: { [key: string]: RequestUser } = {};

  constructor(data?: PartialMessage<RequestedUsers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RequestedUsers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: RequestUser} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestedUsers {
    return new RequestedUsers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestedUsers {
    return new RequestedUsers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestedUsers {
    return new RequestedUsers().fromJsonString(jsonString, options);
  }

  static equals(a: RequestedUsers | PlainMessage<RequestedUsers> | undefined, b: RequestedUsers | PlainMessage<RequestedUsers> | undefined): boolean {
    return proto3.util.equals(RequestedUsers, a, b);
  }
}

/**
 * @generated from message gathertown.RecordingInfo
 */
export class RecordingInfo extends Message<RecordingInfo> {
  /**
   * @generated from field: bool active = 3;
   */
  active = false;

  /**
   * @generated from field: optional string initiatingPlayer = 1;
   */
  initiatingPlayer?: string;

  /**
   * @generated from field: optional string egressId = 4;
   */
  egressId?: string;

  constructor(data?: PartialMessage<RecordingInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RecordingInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "active", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 1, name: "initiatingPlayer", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "egressId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordingInfo {
    return new RecordingInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordingInfo {
    return new RecordingInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordingInfo {
    return new RecordingInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RecordingInfo | PlainMessage<RecordingInfo> | undefined, b: RecordingInfo | PlainMessage<RecordingInfo> | undefined): boolean {
    return proto3.util.equals(RecordingInfo, a, b);
  }
}

/**
 * @generated from message gathertown.NookDiff
 */
export class NookDiff extends Message<NookDiff> {
  /**
   * @generated from field: optional gathertown.NookCoords nookCoords = 1;
   */
  nookCoords?: NookCoords;

  /**
   * @generated from field: optional bool colored = 2;
   */
  colored?: boolean;

  /**
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * @generated from field: optional bool bookable = 4;
   */
  bookable?: boolean;

  /**
   * @generated from field: optional uint32 capacity = 5;
   */
  capacity?: number;

  /**
   * @generated from field: optional bool restricted = 6;
   */
  restricted?: boolean;

  /**
   * @generated from field: optional gathertown.AllowedUsers allowedUsers = 7;
   */
  allowedUsers?: AllowedUsers;

  /**
   * @generated from field: optional gathertown.RequestedUsers requestedUsers = 8;
   */
  requestedUsers?: RequestedUsers;

  /**
   * @generated from field: optional bool isInMeeting = 9;
   */
  isInMeeting?: boolean;

  /**
   * @generated from field: optional bool isDesk = 10;
   */
  isDesk?: boolean;

  /**
   * @generated from field: optional gathertown.RecordingInfo recordingInfo = 11;
   */
  recordingInfo?: RecordingInfo;

  constructor(data?: PartialMessage<NookDiff>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.NookDiff";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nookCoords", kind: "message", T: NookCoords, opt: true },
    { no: 2, name: "colored", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "bookable", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 5, name: "capacity", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "restricted", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 7, name: "allowedUsers", kind: "message", T: AllowedUsers, opt: true },
    { no: 8, name: "requestedUsers", kind: "message", T: RequestedUsers, opt: true },
    { no: 9, name: "isInMeeting", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 10, name: "isDesk", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 11, name: "recordingInfo", kind: "message", T: RecordingInfo, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NookDiff {
    return new NookDiff().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NookDiff {
    return new NookDiff().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NookDiff {
    return new NookDiff().fromJsonString(jsonString, options);
  }

  static equals(a: NookDiff | PlainMessage<NookDiff> | undefined, b: NookDiff | PlainMessage<NookDiff> | undefined): boolean {
    return proto3.util.equals(NookDiff, a, b);
  }
}

/**
 * @generated from message gathertown.WirePoint
 */
export class WirePoint extends Message<WirePoint> {
  /**
   * @generated from field: uint32 x = 1;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 2;
   */
  y = 0;

  constructor(data?: PartialMessage<WirePoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.WirePoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WirePoint {
    return new WirePoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WirePoint {
    return new WirePoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WirePoint {
    return new WirePoint().fromJsonString(jsonString, options);
  }

  static equals(a: WirePoint | PlainMessage<WirePoint> | undefined, b: WirePoint | PlainMessage<WirePoint> | undefined): boolean {
    return proto3.util.equals(WirePoint, a, b);
  }
}

/**
 * @generated from message gathertown.SpawnPoint
 */
export class SpawnPoint extends Message<SpawnPoint> {
  /**
   * @generated from field: uint32 x = 1;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 2;
   */
  y = 0;

  /**
   * @generated from field: optional string spawnId = 3;
   */
  spawnId?: string;

  constructor(data?: PartialMessage<SpawnPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpawnPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "spawnId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpawnPoint {
    return new SpawnPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpawnPoint {
    return new SpawnPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpawnPoint {
    return new SpawnPoint().fromJsonString(jsonString, options);
  }

  static equals(a: SpawnPoint | PlainMessage<SpawnPoint> | undefined, b: SpawnPoint | PlainMessage<SpawnPoint> | undefined): boolean {
    return proto3.util.equals(SpawnPoint, a, b);
  }
}

/**
 * @generated from message gathertown.Portal
 */
export class Portal extends Message<Portal> {
  /**
   * @generated from field: uint32 x = 1;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 2;
   */
  y = 0;

  /**
   * @generated from field: optional string targetMap = 3;
   */
  targetMap?: string;

  /**
   * @generated from field: optional string targetUrl = 4;
   */
  targetUrl?: string;

  /**
   * @generated from field: optional uint32 targetX = 5;
   */
  targetX?: number;

  /**
   * @generated from field: optional uint32 targetY = 6;
   */
  targetY?: number;

  constructor(data?: PartialMessage<Portal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Portal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "targetMap", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "targetUrl", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "targetX", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "targetY", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Portal {
    return new Portal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Portal {
    return new Portal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Portal {
    return new Portal().fromJsonString(jsonString, options);
  }

  static equals(a: Portal | PlainMessage<Portal> | undefined, b: Portal | PlainMessage<Portal> | undefined): boolean {
    return proto3.util.equals(Portal, a, b);
  }
}

/**
 * @generated from message gathertown.Announcer
 */
export class Announcer extends Message<Announcer> {
  /**
   * @generated from field: uint32 x = 1;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 2;
   */
  y = 0;

  constructor(data?: PartialMessage<Announcer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Announcer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Announcer {
    return new Announcer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Announcer {
    return new Announcer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Announcer {
    return new Announcer().fromJsonString(jsonString, options);
  }

  static equals(a: Announcer | PlainMessage<Announcer> | undefined, b: Announcer | PlainMessage<Announcer> | undefined): boolean {
    return proto3.util.equals(Announcer, a, b);
  }
}

/**
 * deprecating (NGN-123)
 *
 * @generated from message gathertown.Asset
 */
export class Asset extends Message<Asset> {
  /**
   * @generated from field: float x = 1;
   */
  x = 0;

  /**
   * @generated from field: float y = 2;
   */
  y = 0;

  /**
   * @generated from field: string src = 3;
   */
  src = "";

  /**
   * @generated from field: optional uint32 width = 4;
   */
  width?: number;

  /**
   * @generated from field: optional uint32 height = 5;
   */
  height?: number;

  /**
   * @generated from field: optional bool inFront = 6;
   */
  inFront?: boolean;

  constructor(data?: PartialMessage<Asset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Asset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "y", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "src", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "width", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 5, name: "height", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "inFront", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Asset {
    return new Asset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Asset {
    return new Asset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Asset {
    return new Asset().fromJsonString(jsonString, options);
  }

  static equals(a: Asset | PlainMessage<Asset> | undefined, b: Asset | PlainMessage<Asset> | undefined): boolean {
    return proto3.util.equals(Asset, a, b);
  }
}

/**
 * @generated from message gathertown.AreaPosition
 */
export class AreaPosition extends Message<AreaPosition> {
  /**
   * @generated from field: uint32 x1 = 1;
   */
  x1 = 0;

  /**
   * @generated from field: uint32 y1 = 2;
   */
  y1 = 0;

  /**
   * @generated from field: uint32 x2 = 3;
   */
  x2 = 0;

  /**
   * @generated from field: uint32 y2 = 4;
   */
  y2 = 0;

  constructor(data?: PartialMessage<AreaPosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.AreaPosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x1", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "y1", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "x2", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "y2", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AreaPosition {
    return new AreaPosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AreaPosition {
    return new AreaPosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AreaPosition {
    return new AreaPosition().fromJsonString(jsonString, options);
  }

  static equals(a: AreaPosition | PlainMessage<AreaPosition> | undefined, b: AreaPosition | PlainMessage<AreaPosition> | undefined): boolean {
    return proto3.util.equals(AreaPosition, a, b);
  }
}

/**
 * @generated from message gathertown.WireArea
 */
export class WireArea extends Message<WireArea> {
  /**
   * @generated from field: optional string category = 1;
   */
  category?: string;

  /**
   * @generated from field: repeated gathertown.AreaPosition coords = 2;
   */
  coords: AreaPosition[] = [];

  constructor(data?: PartialMessage<WireArea>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.WireArea";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "category", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "coords", kind: "message", T: AreaPosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WireArea {
    return new WireArea().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WireArea {
    return new WireArea().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WireArea {
    return new WireArea().fromJsonString(jsonString, options);
  }

  static equals(a: WireArea | PlainMessage<WireArea> | undefined, b: WireArea | PlainMessage<WireArea> | undefined): boolean {
    return proto3.util.equals(WireArea, a, b);
  }
}

/**
 * @generated from message gathertown.DBDesk
 */
export class DBDesk extends Message<DBDesk> {
  /**
   * @generated from field: repeated gathertown.AreaPosition coords = 1;
   */
  coords: AreaPosition[] = [];

  constructor(data?: PartialMessage<DBDesk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.DBDesk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "coords", kind: "message", T: AreaPosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DBDesk {
    return new DBDesk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DBDesk {
    return new DBDesk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DBDesk {
    return new DBDesk().fromJsonString(jsonString, options);
  }

  static equals(a: DBDesk | PlainMessage<DBDesk> | undefined, b: DBDesk | PlainMessage<DBDesk> | undefined): boolean {
    return proto3.util.equals(DBDesk, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetDimensions
 */
export class MapSetDimensions extends Message<MapSetDimensions> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: uint32 width = 2;
   */
  width = 0;

  /**
   * @generated from field: uint32 height = 3;
   */
  height = 0;

  constructor(data?: PartialMessage<MapSetDimensions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetDimensions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "width", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "height", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetDimensions {
    return new MapSetDimensions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetDimensions {
    return new MapSetDimensions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetDimensions {
    return new MapSetDimensions().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetDimensions | PlainMessage<MapSetDimensions> | undefined, b: MapSetDimensions | PlainMessage<MapSetDimensions> | undefined): boolean {
    return proto3.util.equals(MapSetDimensions, a, b);
  }
}

/**
 * this is the new version of impassable. maybe we should rename it?
 *
 * @generated from message gathertown.MapSetCollisions
 */
export class MapSetCollisions extends Message<MapSetCollisions> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * this is the x,y,w,h of the rectangle being updated by this mask
   *
   * @generated from field: uint32 x = 2;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 3;
   */
  y = 0;

  /**
   * @generated from field: uint32 w = 4;
   */
  w = 0;

  /**
   * @generated from field: uint32 h = 5;
   */
  h = 0;

  /**
   * base64 encoded string of bytes, 0x00 is walkable 0x01 is impassable
   *
   * @generated from field: string mask = 6;
   */
  mask = "";

  constructor(data?: PartialMessage<MapSetCollisions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetCollisions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "w", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "h", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "mask", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetCollisions {
    return new MapSetCollisions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetCollisions {
    return new MapSetCollisions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetCollisions {
    return new MapSetCollisions().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetCollisions | PlainMessage<MapSetCollisions> | undefined, b: MapSetCollisions | PlainMessage<MapSetCollisions> | undefined): boolean {
    return proto3.util.equals(MapSetCollisions, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetCollisionsBits
 */
export class MapSetCollisionsBits extends Message<MapSetCollisionsBits> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * indicates whether to overwrite previous collision data (i.e. this represents the entire map) or merge
   *
   * @generated from field: bool overwrite = 2;
   */
  overwrite = false;

  /**
   * this is the x,y,w,h of the rectangle being updated by this mask
   *
   * @generated from field: uint32 x = 3;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 4;
   */
  y = 0;

  /**
   * @generated from field: uint32 w = 5;
   */
  w = 0;

  /**
   * @generated from field: uint32 h = 6;
   */
  h = 0;

  /**
   * the mask stored as bits where 0 is walkable and 1 is impassable
   * to read a single bit:
   *  byteIndex = ((y * w + x) / 8) | 0
   *  bitIndex  = 1 << ((y * w + x) % 8)
   *  impassable = (mask[byteIndex] & (1 << bitIndex)) !== 0
   *
   * @generated from field: bytes mask = 7;
   */
  mask = new Uint8Array(0);

  constructor(data?: PartialMessage<MapSetCollisionsBits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetCollisionsBits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "overwrite", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "w", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "h", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "mask", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetCollisionsBits {
    return new MapSetCollisionsBits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetCollisionsBits {
    return new MapSetCollisionsBits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetCollisionsBits {
    return new MapSetCollisionsBits().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetCollisionsBits | PlainMessage<MapSetCollisionsBits> | undefined, b: MapSetCollisionsBits | PlainMessage<MapSetCollisionsBits> | undefined): boolean {
    return proto3.util.equals(MapSetCollisionsBits, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetBackgroundImagePath
 */
export class MapSetBackgroundImagePath extends Message<MapSetBackgroundImagePath> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * url
   *
   * @generated from field: string backgroundImagePath = 2;
   */
  backgroundImagePath = "";

  constructor(data?: PartialMessage<MapSetBackgroundImagePath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetBackgroundImagePath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "backgroundImagePath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetBackgroundImagePath {
    return new MapSetBackgroundImagePath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetBackgroundImagePath {
    return new MapSetBackgroundImagePath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetBackgroundImagePath {
    return new MapSetBackgroundImagePath().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetBackgroundImagePath | PlainMessage<MapSetBackgroundImagePath> | undefined, b: MapSetBackgroundImagePath | PlainMessage<MapSetBackgroundImagePath> | undefined): boolean {
    return proto3.util.equals(MapSetBackgroundImagePath, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetForegroundImagePath
 */
export class MapSetForegroundImagePath extends Message<MapSetForegroundImagePath> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string foregroundImagePath = 2;
   */
  foregroundImagePath = "";

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetForegroundImagePath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetForegroundImagePath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "foregroundImagePath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetForegroundImagePath {
    return new MapSetForegroundImagePath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetForegroundImagePath {
    return new MapSetForegroundImagePath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetForegroundImagePath {
    return new MapSetForegroundImagePath().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetForegroundImagePath | PlainMessage<MapSetForegroundImagePath> | undefined, b: MapSetForegroundImagePath | PlainMessage<MapSetForegroundImagePath> | undefined): boolean {
    return proto3.util.equals(MapSetForegroundImagePath, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetNooks
 */
export class MapSetNooks extends Message<MapSetNooks> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: map<string, gathertown.NookDiff> nooks = 2;
   */
  nooks: { [key: string]: NookDiff } = {};

  /**
   * @generated from field: optional bool overwrite = 3;
   */
  overwrite?: boolean;

  constructor(data?: PartialMessage<MapSetNooks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetNooks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nooks", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: NookDiff} },
    { no: 3, name: "overwrite", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetNooks {
    return new MapSetNooks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetNooks {
    return new MapSetNooks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetNooks {
    return new MapSetNooks().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetNooks | PlainMessage<MapSetNooks> | undefined, b: MapSetNooks | PlainMessage<MapSetNooks> | undefined): boolean {
    return proto3.util.equals(MapSetNooks, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetSpawn
 */
export class MapSetSpawn extends Message<MapSetSpawn> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: gathertown.WirePoint spawn = 2;
   */
  spawn?: WirePoint;

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetSpawn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetSpawn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "spawn", kind: "message", T: WirePoint },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetSpawn {
    return new MapSetSpawn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetSpawn {
    return new MapSetSpawn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetSpawn {
    return new MapSetSpawn().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetSpawn | PlainMessage<MapSetSpawn> | undefined, b: MapSetSpawn | PlainMessage<MapSetSpawn> | undefined): boolean {
    return proto3.util.equals(MapSetSpawn, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetSpawns
 */
export class MapSetSpawns extends Message<MapSetSpawns> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: repeated gathertown.SpawnPoint spawns = 2;
   */
  spawns: SpawnPoint[] = [];

  constructor(data?: PartialMessage<MapSetSpawns>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetSpawns";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "spawns", kind: "message", T: SpawnPoint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetSpawns {
    return new MapSetSpawns().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetSpawns {
    return new MapSetSpawns().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetSpawns {
    return new MapSetSpawns().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetSpawns | PlainMessage<MapSetSpawns> | undefined, b: MapSetSpawns | PlainMessage<MapSetSpawns> | undefined): boolean {
    return proto3.util.equals(MapSetSpawns, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetPortals
 */
export class MapSetPortals extends Message<MapSetPortals> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: repeated gathertown.Portal portals = 2;
   */
  portals: Portal[] = [];

  constructor(data?: PartialMessage<MapSetPortals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetPortals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "portals", kind: "message", T: Portal, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetPortals {
    return new MapSetPortals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetPortals {
    return new MapSetPortals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetPortals {
    return new MapSetPortals().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetPortals | PlainMessage<MapSetPortals> | undefined, b: MapSetPortals | PlainMessage<MapSetPortals> | undefined): boolean {
    return proto3.util.equals(MapSetPortals, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetAnnouncer
 */
export class MapSetAnnouncer extends Message<MapSetAnnouncer> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: repeated gathertown.Announcer announcer = 2;
   */
  announcer: Announcer[] = [];

  constructor(data?: PartialMessage<MapSetAnnouncer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetAnnouncer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "announcer", kind: "message", T: Announcer, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetAnnouncer {
    return new MapSetAnnouncer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetAnnouncer {
    return new MapSetAnnouncer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetAnnouncer {
    return new MapSetAnnouncer().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetAnnouncer | PlainMessage<MapSetAnnouncer> | undefined, b: MapSetAnnouncer | PlainMessage<MapSetAnnouncer> | undefined): boolean {
    return proto3.util.equals(MapSetAnnouncer, a, b);
  }
}

/**
 * deprecating (NGN-123)
 *
 * @generated from message gathertown.MapSetAssets
 */
export class MapSetAssets extends Message<MapSetAssets> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: repeated gathertown.Asset assets = 2;
   */
  assets: Asset[] = [];

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetAssets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetAssets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "assets", kind: "message", T: Asset, repeated: true },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetAssets {
    return new MapSetAssets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetAssets {
    return new MapSetAssets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetAssets {
    return new MapSetAssets().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetAssets | PlainMessage<MapSetAssets> | undefined, b: MapSetAssets | PlainMessage<MapSetAssets> | undefined): boolean {
    return proto3.util.equals(MapSetAssets, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetObjectsV2
 */
export class MapSetObjectsV2 extends Message<MapSetObjectsV2> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: map<string, gathertown.WireObject> objects = 2;
   */
  objects: { [key: string]: WireObject } = {};

  /**
   * @generated from field: optional bool updatesAreOverwrites = 3;
   */
  updatesAreOverwrites?: boolean;

  constructor(data?: PartialMessage<MapSetObjectsV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetObjectsV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "objects", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: WireObject} },
    { no: 3, name: "updatesAreOverwrites", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetObjectsV2 {
    return new MapSetObjectsV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetObjectsV2 {
    return new MapSetObjectsV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetObjectsV2 {
    return new MapSetObjectsV2().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetObjectsV2 | PlainMessage<MapSetObjectsV2> | undefined, b: MapSetObjectsV2 | PlainMessage<MapSetObjectsV2> | undefined): boolean {
    return proto3.util.equals(MapSetObjectsV2, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetName
 */
export class MapSetName extends Message<MapSetName> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetName";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetName {
    return new MapSetName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetName {
    return new MapSetName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetName {
    return new MapSetName().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetName | PlainMessage<MapSetName> | undefined, b: MapSetName | PlainMessage<MapSetName> | undefined): boolean {
    return proto3.util.equals(MapSetName, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetMuteOnEntry
 */
export class MapSetMuteOnEntry extends Message<MapSetMuteOnEntry> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: bool muteOnEntry = 2;
   */
  muteOnEntry = false;

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetMuteOnEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetMuteOnEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "muteOnEntry", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetMuteOnEntry {
    return new MapSetMuteOnEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetMuteOnEntry {
    return new MapSetMuteOnEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetMuteOnEntry {
    return new MapSetMuteOnEntry().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetMuteOnEntry | PlainMessage<MapSetMuteOnEntry> | undefined, b: MapSetMuteOnEntry | PlainMessage<MapSetMuteOnEntry> | undefined): boolean {
    return proto3.util.equals(MapSetMuteOnEntry, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetUseDrawnBG
 */
export class MapSetUseDrawnBG extends Message<MapSetUseDrawnBG> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: bool useDrawnBG = 2;
   */
  useDrawnBG = false;

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetUseDrawnBG>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetUseDrawnBG";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "useDrawnBG", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetUseDrawnBG {
    return new MapSetUseDrawnBG().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetUseDrawnBG {
    return new MapSetUseDrawnBG().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetUseDrawnBG {
    return new MapSetUseDrawnBG().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetUseDrawnBG | PlainMessage<MapSetUseDrawnBG> | undefined, b: MapSetUseDrawnBG | PlainMessage<MapSetUseDrawnBG> | undefined): boolean {
    return proto3.util.equals(MapSetUseDrawnBG, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetWalls
 */
export class MapSetWalls extends Message<MapSetWalls> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: map<string, string> walls = 2;
   */
  walls: { [key: string]: string } = {};

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetWalls>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetWalls";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "walls", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetWalls {
    return new MapSetWalls().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetWalls {
    return new MapSetWalls().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetWalls {
    return new MapSetWalls().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetWalls | PlainMessage<MapSetWalls> | undefined, b: MapSetWalls | PlainMessage<MapSetWalls> | undefined): boolean {
    return proto3.util.equals(MapSetWalls, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetFloors
 */
export class MapSetFloors extends Message<MapSetFloors> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: map<string, string> floors = 2;
   */
  floors: { [key: string]: string } = {};

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetFloors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetFloors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "floors", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetFloors {
    return new MapSetFloors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetFloors {
    return new MapSetFloors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetFloors {
    return new MapSetFloors().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetFloors | PlainMessage<MapSetFloors> | undefined, b: MapSetFloors | PlainMessage<MapSetFloors> | undefined): boolean {
    return proto3.util.equals(MapSetFloors, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetAreas
 */
export class MapSetAreas extends Message<MapSetAreas> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: map<string, gathertown.WireArea> areas = 2;
   */
  areas: { [key: string]: WireArea } = {};

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetAreas>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetAreas";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "areas", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: WireArea} },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetAreas {
    return new MapSetAreas().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetAreas {
    return new MapSetAreas().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetAreas {
    return new MapSetAreas().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetAreas | PlainMessage<MapSetAreas> | undefined, b: MapSetAreas | PlainMessage<MapSetAreas> | undefined): boolean {
    return proto3.util.equals(MapSetAreas, a, b);
  }
}

/**
 * @generated from message gathertown.MapDeleteObjectByKey
 */
export class MapDeleteObjectByKey extends Message<MapDeleteObjectByKey> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  constructor(data?: PartialMessage<MapDeleteObjectByKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapDeleteObjectByKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapDeleteObjectByKey {
    return new MapDeleteObjectByKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapDeleteObjectByKey {
    return new MapDeleteObjectByKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapDeleteObjectByKey {
    return new MapDeleteObjectByKey().fromJsonString(jsonString, options);
  }

  static equals(a: MapDeleteObjectByKey | PlainMessage<MapDeleteObjectByKey> | undefined, b: MapDeleteObjectByKey | PlainMessage<MapDeleteObjectByKey> | undefined): boolean {
    return proto3.util.equals(MapDeleteObjectByKey, a, b);
  }
}

/**
 * @generated from message gathertown.MapDeleteObjectById
 */
export class MapDeleteObjectById extends Message<MapDeleteObjectById> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<MapDeleteObjectById>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapDeleteObjectById";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapDeleteObjectById {
    return new MapDeleteObjectById().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapDeleteObjectById {
    return new MapDeleteObjectById().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapDeleteObjectById {
    return new MapDeleteObjectById().fromJsonString(jsonString, options);
  }

  static equals(a: MapDeleteObjectById | PlainMessage<MapDeleteObjectById> | undefined, b: MapDeleteObjectById | PlainMessage<MapDeleteObjectById> | undefined): boolean {
    return proto3.util.equals(MapDeleteObjectById, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetMiniMapImagePath
 */
export class MapSetMiniMapImagePath extends Message<MapSetMiniMapImagePath> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string miniMapImagePath = 2;
   */
  miniMapImagePath = "";

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetMiniMapImagePath>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetMiniMapImagePath";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "miniMapImagePath", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetMiniMapImagePath {
    return new MapSetMiniMapImagePath().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetMiniMapImagePath {
    return new MapSetMiniMapImagePath().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetMiniMapImagePath {
    return new MapSetMiniMapImagePath().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetMiniMapImagePath | PlainMessage<MapSetMiniMapImagePath> | undefined, b: MapSetMiniMapImagePath | PlainMessage<MapSetMiniMapImagePath> | undefined): boolean {
    return proto3.util.equals(MapSetMiniMapImagePath, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetEnabledChats
 */
export class MapSetEnabledChats extends Message<MapSetEnabledChats> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: repeated string enabledChats = 2;
   */
  enabledChats: string[] = [];

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetEnabledChats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetEnabledChats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enabledChats", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetEnabledChats {
    return new MapSetEnabledChats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetEnabledChats {
    return new MapSetEnabledChats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetEnabledChats {
    return new MapSetEnabledChats().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetEnabledChats | PlainMessage<MapSetEnabledChats> | undefined, b: MapSetEnabledChats | PlainMessage<MapSetEnabledChats> | undefined): boolean {
    return proto3.util.equals(MapSetEnabledChats, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetDescription
 */
export class MapSetDescription extends Message<MapSetDescription> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetDescription {
    return new MapSetDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetDescription {
    return new MapSetDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetDescription {
    return new MapSetDescription().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetDescription | PlainMessage<MapSetDescription> | undefined, b: MapSetDescription | PlainMessage<MapSetDescription> | undefined): boolean {
    return proto3.util.equals(MapSetDescription, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetDecoration
 */
export class MapSetDecoration extends Message<MapSetDecoration> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string decoration = 2;
   */
  decoration = "";

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetDecoration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetDecoration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "decoration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetDecoration {
    return new MapSetDecoration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetDecoration {
    return new MapSetDecoration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetDecoration {
    return new MapSetDecoration().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetDecoration | PlainMessage<MapSetDecoration> | undefined, b: MapSetDecoration | PlainMessage<MapSetDecoration> | undefined): boolean {
    return proto3.util.equals(MapSetDecoration, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetTutorialTasks
 */
export class MapSetTutorialTasks extends Message<MapSetTutorialTasks> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: gathertown.WireTutorialTasks tutorialTasks = 2;
   */
  tutorialTasks?: WireTutorialTasks;

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetTutorialTasks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetTutorialTasks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tutorialTasks", kind: "message", T: WireTutorialTasks },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetTutorialTasks {
    return new MapSetTutorialTasks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetTutorialTasks {
    return new MapSetTutorialTasks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetTutorialTasks {
    return new MapSetTutorialTasks().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetTutorialTasks | PlainMessage<MapSetTutorialTasks> | undefined, b: MapSetTutorialTasks | PlainMessage<MapSetTutorialTasks> | undefined): boolean {
    return proto3.util.equals(MapSetTutorialTasks, a, b);
  }
}

/**
 * @generated from message gathertown.WireTutorialTasks
 */
export class WireTutorialTasks extends Message<WireTutorialTasks> {
  /**
   * @generated from field: string groupSetId = 1;
   */
  groupSetId = "";

  /**
   * @generated from field: repeated gathertown.TutorialTaskMapArea areas = 2;
   */
  areas: TutorialTaskMapArea[] = [];

  /**
   * @generated from field: optional bool autoStart = 3;
   */
  autoStart?: boolean;

  constructor(data?: PartialMessage<WireTutorialTasks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.WireTutorialTasks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "groupSetId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "areas", kind: "message", T: TutorialTaskMapArea, repeated: true },
    { no: 3, name: "autoStart", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WireTutorialTasks {
    return new WireTutorialTasks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WireTutorialTasks {
    return new WireTutorialTasks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WireTutorialTasks {
    return new WireTutorialTasks().fromJsonString(jsonString, options);
  }

  static equals(a: WireTutorialTasks | PlainMessage<WireTutorialTasks> | undefined, b: WireTutorialTasks | PlainMessage<WireTutorialTasks> | undefined): boolean {
    return proto3.util.equals(WireTutorialTasks, a, b);
  }
}

/**
 * @generated from message gathertown.TutorialTaskMapArea
 */
export class TutorialTaskMapArea extends Message<TutorialTaskMapArea> {
  /**
   * @generated from field: string areaId = 1;
   */
  areaId = "";

  /**
   * @generated from field: uint32 x = 2;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 3;
   */
  y = 0;

  /**
   * @generated from field: uint32 height = 4;
   */
  height = 0;

  /**
   * @generated from field: uint32 width = 5;
   */
  width = 0;

  constructor(data?: PartialMessage<TutorialTaskMapArea>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.TutorialTaskMapArea";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "areaId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "height", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "width", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TutorialTaskMapArea {
    return new TutorialTaskMapArea().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TutorialTaskMapArea {
    return new TutorialTaskMapArea().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TutorialTaskMapArea {
    return new TutorialTaskMapArea().fromJsonString(jsonString, options);
  }

  static equals(a: TutorialTaskMapArea | PlainMessage<TutorialTaskMapArea> | undefined, b: TutorialTaskMapArea | PlainMessage<TutorialTaskMapArea> | undefined): boolean {
    return proto3.util.equals(TutorialTaskMapArea, a, b);
  }
}

/**
 * @generated from message gathertown.MapSetScript
 */
export class MapSetScript extends Message<MapSetScript> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string script = 2;
   */
  script = "";

  /**
   * @generated from field: optional bool delete = 3;
   */
  delete?: boolean;

  constructor(data?: PartialMessage<MapSetScript>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapSetScript";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "script", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "delete", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapSetScript {
    return new MapSetScript().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapSetScript {
    return new MapSetScript().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapSetScript {
    return new MapSetScript().fromJsonString(jsonString, options);
  }

  static equals(a: MapSetScript | PlainMessage<MapSetScript> | undefined, b: MapSetScript | PlainMessage<MapSetScript> | undefined): boolean {
    return proto3.util.equals(MapSetScript, a, b);
  }
}

/**
 * @generated from message gathertown.Inventory
 */
export class Inventory extends Message<Inventory> {
  /**
   * @generated from field: map<string, gathertown.InventoryItem> items = 1;
   */
  items: { [key: string]: InventoryItem } = {};

  /**
   * @generated from field: map<string, string> order = 2;
   */
  order: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Inventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Inventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: InventoryItem} },
    { no: 2, name: "order", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Inventory {
    return new Inventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Inventory {
    return new Inventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Inventory {
    return new Inventory().fromJsonString(jsonString, options);
  }

  static equals(a: Inventory | PlainMessage<Inventory> | undefined, b: Inventory | PlainMessage<Inventory> | undefined): boolean {
    return proto3.util.equals(Inventory, a, b);
  }
}

/**
 * @generated from message gathertown.InventoryItem
 */
export class InventoryItem extends Message<InventoryItem> {
  /**
   * @generated from field: uint32 count = 1;
   */
  count = 0;

  constructor(data?: PartialMessage<InventoryItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.InventoryItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InventoryItem {
    return new InventoryItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InventoryItem {
    return new InventoryItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InventoryItem {
    return new InventoryItem().fromJsonString(jsonString, options);
  }

  static equals(a: InventoryItem | PlainMessage<InventoryItem> | undefined, b: InventoryItem | PlainMessage<InventoryItem> | undefined): boolean {
    return proto3.util.equals(InventoryItem, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceItem
 */
export class SpaceItem extends Message<SpaceItem> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: optional string category = 2;
   */
  category?: string;

  /**
   * @generated from field: optional string description = 3;
   */
  description?: string;

  /**
   * @generated from field: string previewUrl = 4;
   */
  previewUrl = "";

  /**
   * @generated from field: map<string, string> meta = 5;
   */
  meta: { [key: string]: string } = {};

  /**
   * @generated from field: map<string, gathertown.ItemAbility> abilities = 6;
   */
  abilities: { [key: string]: ItemAbility } = {};

  constructor(data?: PartialMessage<SpaceItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "category", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "previewUrl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "meta", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 6, name: "abilities", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ItemAbility} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceItem {
    return new SpaceItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceItem {
    return new SpaceItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceItem {
    return new SpaceItem().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceItem | PlainMessage<SpaceItem> | undefined, b: SpaceItem | PlainMessage<SpaceItem> | undefined): boolean {
    return proto3.util.equals(SpaceItem, a, b);
  }
}

/**
 * @generated from message gathertown.ItemAbility
 */
export class ItemAbility extends Message<ItemAbility> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<ItemAbility>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ItemAbility";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ItemAbility {
    return new ItemAbility().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ItemAbility {
    return new ItemAbility().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ItemAbility {
    return new ItemAbility().fromJsonString(jsonString, options);
  }

  static equals(a: ItemAbility | PlainMessage<ItemAbility> | undefined, b: ItemAbility | PlainMessage<ItemAbility> | undefined): boolean {
    return proto3.util.equals(ItemAbility, a, b);
  }
}

/**
 * @generated from message gathertown.MapLocation
 */
export class MapLocation extends Message<MapLocation> {
  /**
   * @generated from field: string map = 1;
   */
  map = "";

  /**
   * @generated from field: uint32 x = 2;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 3;
   */
  y = 0;

  constructor(data?: PartialMessage<MapLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "map", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapLocation {
    return new MapLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapLocation {
    return new MapLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapLocation {
    return new MapLocation().fromJsonString(jsonString, options);
  }

  static equals(a: MapLocation | PlainMessage<MapLocation> | undefined, b: MapLocation | PlainMessage<MapLocation> | undefined): boolean {
    return proto3.util.equals(MapLocation, a, b);
  }
}

/**
 * @generated from message gathertown.ServerClientBatch
 */
export class ServerClientBatch extends Message<ServerClientBatch> {
  /**
   * don't add more stuff here
   *
   * @generated from field: repeated gathertown.ServerClientEvent events = 1;
   */
  events: ServerClientEvent[] = [];

  constructor(data?: PartialMessage<ServerClientBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ServerClientBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: ServerClientEvent, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerClientBatch {
    return new ServerClientBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerClientBatch {
    return new ServerClientBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerClientBatch {
    return new ServerClientBatch().fromJsonString(jsonString, options);
  }

  static equals(a: ServerClientBatch | PlainMessage<ServerClientBatch> | undefined, b: ServerClientBatch | PlainMessage<ServerClientBatch> | undefined): boolean {
    return proto3.util.equals(ServerClientBatch, a, b);
  }
}

/**
 * @generated from message gathertown.ServerClientEvent
 */
export class ServerClientEvent extends Message<ServerClientEvent> {
  /**
   * @generated from oneof gathertown.ServerClientEvent.event
   */
  event: {
    /**
     * @generated from field: gathertown.Info info = 100;
     */
    value: Info;
    case: "info";
  } | {
    /**
     * @generated from field: gathertown.Warn warn = 101;
     */
    value: Warn;
    case: "warn";
  } | {
    /**
     * @generated from field: gathertown.ErrorEvent error = 102;
     */
    value: ErrorEvent;
    case: "error";
  } | {
    /**
     * @generated from field: gathertown.Ready ready = 103;
     */
    value: Ready;
    case: "ready";
  } | {
    /**
     * @generated from field: gathertown.ServerHeartbeat serverHeartbeat = 105;
     */
    value: ServerHeartbeat;
    case: "serverHeartbeat";
  } | {
    /**
     * @generated from field: gathertown.TransactionStatus transactionStatus = 107;
     */
    value: TransactionStatus;
    case: "transactionStatus";
  } | {
    /**
     * @generated from field: gathertown.PlayerMoves playerMoves = 1;
     */
    value: PlayerMoves;
    case: "playerMoves";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsStatus playerSetsStatus = 5;
     */
    value: PlayerSetsStatus;
    case: "playerSetsStatus";
  } | {
    /**
     * @generated from field: gathertown.PlayerSpotlights playerSpotlights = 6;
     */
    value: PlayerSpotlights;
    case: "playerSpotlights";
  } | {
    /**
     * @generated from field: gathertown.PlayerRings playerRings = 7;
     */
    value: PlayerRings;
    case: "playerRings";
  } | {
    /**
     * @generated from field: gathertown.PlayerChats playerChats = 9;
     */
    value: PlayerChats;
    case: "playerChats";
  } | {
    /**
     * @generated from field: gathertown.PlayerGhosts playerGhosts = 11;
     */
    value: PlayerGhosts;
    case: "playerGhosts";
  } | {
    /**
     * deprecating (NGN-114)
     *
     * @generated from field: gathertown.PlayerEntersWhisper playerEntersWhisper = 12;
     */
    value: PlayerEntersWhisper;
    case: "playerEntersWhisper";
  } | {
    /**
     * @generated from field: gathertown.PlayerLeavesWhisper playerLeavesWhisper = 13;
     */
    value: PlayerLeavesWhisper;
    case: "playerLeavesWhisper";
  } | {
    /**
     * @generated from field: gathertown.PlayerActivelySpeaks playerActivelySpeaks = 14;
     */
    value: PlayerActivelySpeaks;
    case: "playerActivelySpeaks";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsName playerSetsName = 17;
     */
    value: PlayerSetsName;
    case: "playerSetsName";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsTextStatus playerSetsTextStatus = 18;
     */
    value: PlayerSetsTextStatus;
    case: "playerSetsTextStatus";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsEmojiStatus playerSetsEmojiStatus = 19;
     */
    value: PlayerSetsEmojiStatus;
    case: "playerSetsEmojiStatus";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsAffiliation playerSetsAffiliation = 20;
     */
    value: PlayerSetsAffiliation;
    case: "playerSetsAffiliation";
  } | {
    /**
     * @generated from field: gathertown.PlayerExits playerExits = 21;
     */
    value: PlayerExits;
    case: "playerExits";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsIsSignedIn playerSetsIsSignedIn = 41;
     */
    value: PlayerSetsIsSignedIn;
    case: "playerSetsIsSignedIn";
  } | {
    /**
     * @generated from field: gathertown.SpaceOverwrites spaceOverwrites = 44;
     */
    value: SpaceOverwrites;
    case: "spaceOverwrites";
  } | {
    /**
     * @generated from field: gathertown.SpaceIsClosed spaceIsClosed = 45;
     */
    value: SpaceIsClosed;
    case: "spaceIsClosed";
  } | {
    /**
     * @generated from field: gathertown.PlayerEntersPortal playerEntersPortal = 46;
     */
    value: PlayerEntersPortal;
    case: "playerEntersPortal";
  } | {
    /**
     * @generated from field: gathertown.SpaceSetsIdMapping spaceSetsIdMapping = 47;
     */
    value: SpaceSetsIdMapping;
    case: "spaceSetsIdMapping";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.PlayerSetsLastActive playerSetsLastActive = 48;
     */
    value: PlayerSetsLastActive;
    case: "playerSetsLastActive";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.PlayerShootsConfetti playerShootsConfetti = 49;
     */
    value: PlayerShootsConfetti;
    case: "playerShootsConfetti";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.PlayerSetsEventStatus playerSetsEventStatus = 50;
     */
    value: PlayerSetsEventStatus;
    case: "playerSetsEventStatus";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.PlayerSetsInConversation playerSetsInConversation = 51;
     */
    value: PlayerSetsInConversation;
    case: "playerSetsInConversation";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.PlayerSetsCurrentArea playerSetsCurrentArea = 53;
     */
    value: PlayerSetsCurrentArea;
    case: "playerSetsCurrentArea";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsImagePointer playerSetsImagePointer = 54;
     */
    value: PlayerSetsImagePointer;
    case: "playerSetsImagePointer";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.CookieFound cookieFound = 55;
     */
    value: CookieFound;
    case: "cookieFound";
  } | {
    /**
     * @generated from field: gathertown.PlayerEntersWhisperV2 playerEntersWhisperV2 = 56;
     */
    value: PlayerEntersWhisperV2;
    case: "playerEntersWhisperV2";
  } | {
    /**
     * deprecated (NGN-709)
     *
     * @generated from field: gathertown.PlayerSetsGoKartId playerSetsGoKartId = 57;
     */
    value: PlayerSetsGoKartId;
    case: "playerSetsGoKartId";
  } | {
    /**
     * @generated from field: gathertown.MapSetDimensions mapSetDimensions = 58;
     */
    value: MapSetDimensions;
    case: "mapSetDimensions";
  } | {
    /**
     * @generated from field: gathertown.MapSetBackgroundImagePath mapSetBackgroundImagePath = 60;
     */
    value: MapSetBackgroundImagePath;
    case: "mapSetBackgroundImagePath";
  } | {
    /**
     * @generated from field: gathertown.MapSetForegroundImagePath mapSetForegroundImagePath = 61;
     */
    value: MapSetForegroundImagePath;
    case: "mapSetForegroundImagePath";
  } | {
    /**
     * @generated from field: gathertown.MapSetSpawns mapSetSpawns = 64;
     */
    value: MapSetSpawns;
    case: "mapSetSpawns";
  } | {
    /**
     * @generated from field: gathertown.MapSetPortals mapSetPortals = 65;
     */
    value: MapSetPortals;
    case: "mapSetPortals";
  } | {
    /**
     * @generated from field: gathertown.MapSetAnnouncer mapSetAnnouncer = 66;
     */
    value: MapSetAnnouncer;
    case: "mapSetAnnouncer";
  } | {
    /**
     * deprecating (NGN-123)
     *
     * @generated from field: gathertown.MapSetAssets mapSetAssets = 69;
     */
    value: MapSetAssets;
    case: "mapSetAssets";
  } | {
    /**
     * @generated from field: gathertown.MapSetName mapSetName = 71;
     */
    value: MapSetName;
    case: "mapSetName";
  } | {
    /**
     * @generated from field: gathertown.MapSetMuteOnEntry mapSetMuteOnEntry = 73;
     */
    value: MapSetMuteOnEntry;
    case: "mapSetMuteOnEntry";
  } | {
    /**
     * @generated from field: gathertown.MapSetUseDrawnBG mapSetUseDrawnBG = 74;
     */
    value: MapSetUseDrawnBG;
    case: "mapSetUseDrawnBG";
  } | {
    /**
     * @generated from field: gathertown.MapSetWalls mapSetWalls = 75;
     */
    value: MapSetWalls;
    case: "mapSetWalls";
  } | {
    /**
     * @generated from field: gathertown.MapSetFloors mapSetFloors = 76;
     */
    value: MapSetFloors;
    case: "mapSetFloors";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.MapSetAreas mapSetAreas = 77;
     */
    value: MapSetAreas;
    case: "mapSetAreas";
  } | {
    /**
     * deprecating (NGN-104)
     *
     * @generated from field: gathertown.MapSetSpawn mapSetSpawn = 79;
     */
    value: MapSetSpawn;
    case: "mapSetSpawn";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.PlayerSetsIsAlone playerSetsIsAlone = 80;
     */
    value: PlayerSetsIsAlone;
    case: "playerSetsIsAlone";
  } | {
    /**
     * @generated from field: gathertown.PlayerJoins playerJoins = 81;
     */
    value: PlayerJoins;
    case: "playerJoins";
  } | {
    /**
     * @generated from field: gathertown.MapSetEnabledChats mapSetEnabledChats = 82;
     */
    value: MapSetEnabledChats;
    case: "mapSetEnabledChats";
  } | {
    /**
     * @generated from field: gathertown.MapSetDescription mapSetDescription = 83;
     */
    value: MapSetDescription;
    case: "mapSetDescription";
  } | {
    /**
     * @generated from field: gathertown.MapSetDecoration mapSetDecoration = 84;
     */
    value: MapSetDecoration;
    case: "mapSetDecoration";
  } | {
    /**
     * @generated from field: gathertown.MapSetTutorialTasks mapSetTutorialTasks = 85;
     */
    value: MapSetTutorialTasks;
    case: "mapSetTutorialTasks";
  } | {
    /**
     * @generated from field: gathertown.MapSetMiniMapImagePath mapSetMiniMapImagePath = 86;
     */
    value: MapSetMiniMapImagePath;
    case: "mapSetMiniMapImagePath";
  } | {
    /**
     * @generated from field: gathertown.SpacePlaysSound spacePlaysSound = 87;
     */
    value: SpacePlaysSound;
    case: "spacePlaysSound";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.MapSetScript mapSetScript = 88;
     */
    value: MapSetScript;
    case: "mapSetScript";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.PlayerSetsIsMobile playerSetsIsMobile = 90;
     */
    value: PlayerSetsIsMobile;
    case: "playerSetsIsMobile";
  } | {
    /**
     * @generated from field: gathertown.SetScreenPointerServer setScreenPointerServer = 91;
     */
    value: SetScreenPointerServer;
    case: "setScreenPointerServer";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsEmoteV2 playerSetsEmoteV2 = 92;
     */
    value: PlayerSetsEmoteV2;
    case: "playerSetsEmoteV2";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.PlayerSetsFocusModeEndTime playerSetsFocusModeEndTime = 93;
     */
    value: PlayerSetsFocusModeEndTime;
    case: "playerSetsFocusModeEndTime";
  } | {
    /**
     * deprecating soon (NGN-762)
     *
     * @generated from field: gathertown.SpaceSetsSpaceMembers spaceSetsSpaceMembers = 94;
     */
    value: SpaceSetsSpaceMembers;
    case: "spaceSetsSpaceMembers";
  } | {
    /**
     * @generated from field: gathertown.SpaceSetsSpaceUsers spaceSetsSpaceUsers = 167;
     */
    value: SpaceSetsSpaceUsers;
    case: "spaceSetsSpaceUsers";
  } | {
    /**
     * @generated from field: gathertown.CustomEvent customEvent = 95;
     */
    value: CustomEvent;
    case: "customEvent";
  } | {
    /**
     * @generated from field: gathertown.PlayerBlocks playerBlocks = 97;
     */
    value: PlayerBlocks;
    case: "playerBlocks";
  } | {
    /**
     * @generated from field: gathertown.PlayerUpdatesFocusModeStatus playerUpdatesFocusModeStatus = 98;
     */
    value: PlayerUpdatesFocusModeStatus;
    case: "playerUpdatesFocusModeStatus";
  } | {
    /**
     * @generated from field: gathertown.PlayerNotifies playerNotifies = 99;
     */
    value: PlayerNotifies;
    case: "playerNotifies";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsItemString playerSetsItemString = 108;
     */
    value: PlayerSetsItemString;
    case: "playerSetsItemString";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsFollowTarget playerSetsFollowTarget = 110;
     */
    value: PlayerSetsFollowTarget;
    case: "playerSetsFollowTarget";
  } | {
    /**
     * @generated from field: gathertown.PlayerRequestsToLead playerRequestsToLead = 111;
     */
    value: PlayerRequestsToLead;
    case: "playerRequestsToLead";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsManualVideoSrc playerSetsManualVideoSrc = 112;
     */
    value: PlayerSetsManualVideoSrc;
    case: "playerSetsManualVideoSrc";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsIsNpc playerSetsIsNpc = 113;
     */
    value: PlayerSetsIsNpc;
    case: "playerSetsIsNpc";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsSubtitle playerSetsSubtitle = 114;
     */
    value: PlayerSetsSubtitle;
    case: "playerSetsSubtitle";
  } | {
    /**
     * @generated from field: gathertown.MapCommitsChanges mapCommitsChanges = 115;
     */
    value: MapCommitsChanges;
    case: "mapCommitsChanges";
  } | {
    /**
     * @generated from field: gathertown.MapMoveObject mapMoveObject = 117;
     */
    value: MapMoveObject;
    case: "mapMoveObject";
  } | {
    /**
     * @generated from field: gathertown.PlayerEditsChatMessage playerEditsChatMessage = 118;
     */
    value: PlayerEditsChatMessage;
    case: "playerEditsChatMessage";
  } | {
    /**
     * @generated from field: gathertown.FXShakeObject fxShakeObject = 119;
     */
    value: FXShakeObject;
    case: "fxShakeObject";
  } | {
    /**
     * @generated from field: gathertown.FXShakeCamera fxShakeCamera = 120;
     */
    value: FXShakeCamera;
    case: "fxShakeCamera";
  } | {
    /**
     * @generated from field: gathertown.PlayerSendsCommand playerSendsCommand = 121;
     */
    value: PlayerSendsCommand;
    case: "playerSendsCommand";
  } | {
    /**
     * @generated from field: gathertown.SpaceRegistersCommand spaceRegistersCommand = 122;
     */
    value: SpaceRegistersCommand;
    case: "spaceRegistersCommand";
  } | {
    /**
     * @generated from field: gathertown.SpeakerUpdatesSession speakerUpdatesSession = 123;
     */
    value: SpeakerUpdatesSession;
    case: "speakerUpdatesSession";
  } | {
    /**
     * @generated from field: gathertown.PlayerUpdatesInventory playerUpdatesInventory = 124;
     */
    value: PlayerUpdatesInventory;
    case: "playerUpdatesInventory";
  } | {
    /**
     * @generated from field: gathertown.SpaceUpdatesItems spaceUpdatesItems = 125;
     */
    value: SpaceUpdatesItems;
    case: "spaceUpdatesItems";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsVehicleId playerSetsVehicleId = 126;
     */
    value: PlayerSetsVehicleId;
    case: "playerSetsVehicleId";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsSpeedModifier playerSetsSpeedModifier = 127;
     */
    value: PlayerSetsSpeedModifier;
    case: "playerSetsSpeedModifier";
  } | {
    /**
     * @generated from field: gathertown.PlayerHighFives playerHighFives = 128;
     */
    value: PlayerHighFives;
    case: "playerHighFives";
  } | {
    /**
     * @generated from field: gathertown.SpaceStopsSound spaceStopsSound = 130;
     */
    value: SpaceStopsSound;
    case: "spaceStopsSound";
  } | {
    /**
     * @generated from field: gathertown.HipToBeSquare hipToBeSquare = 131;
     */
    value: HipToBeSquare;
    case: "hipToBeSquare";
  } | {
    /**
     * @generated from field: gathertown.PlayerCrafts playerCrafts = 132;
     */
    value: PlayerCrafts;
    case: "playerCrafts";
  } | {
    /**
     * @generated from field: gathertown.PlayerTriggersInventoryItem playerTriggersInventoryItem = 133;
     */
    value: PlayerTriggersInventoryItem;
    case: "playerTriggersInventoryItem";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsAllowScreenPointer playerSetsAllowScreenPointer = 134;
     */
    value: PlayerSetsAllowScreenPointer;
    case: "playerSetsAllowScreenPointer";
  } | {
    /**
     * @generated from field: gathertown.PrecomputedEnterLocation precomputedEnterLocation = 135;
     */
    value: PrecomputedEnterLocation;
    case: "precomputedEnterLocation";
  } | {
    /**
     * @generated from field: gathertown.GotRequestMute gotRequestMute = 136;
     */
    value: GotRequestMute;
    case: "gotRequestMute";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsDeskInfo playerSetsDeskInfo = 137;
     */
    value: PlayerSetsDeskInfo;
    case: "playerSetsDeskInfo";
  } | {
    /**
     * @generated from field: gathertown.MapSetNooks mapSetNooks = 138;
     */
    value: MapSetNooks;
    case: "mapSetNooks";
  } | {
    /**
     * @generated from field: gathertown.DynamicGates dynamicGates = 139;
     */
    value: DynamicGates;
    case: "dynamicGates";
  } | {
    /**
     * @generated from field: gathertown.PlayerWaves playerWaves = 140;
     */
    value: PlayerWaves;
    case: "playerWaves";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsPronouns playerSetsPronouns = 141;
     */
    value: PlayerSetsPronouns;
    case: "playerSetsPronouns";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsTitle playerSetsTitle = 142;
     */
    value: PlayerSetsTitle;
    case: "playerSetsTitle";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsTimezone playerSetsTimezone = 143;
     */
    value: PlayerSetsTimezone;
    case: "playerSetsTimezone";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsDescription playerSetsDescription = 144;
     */
    value: PlayerSetsDescription;
    case: "playerSetsDescription";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsPhone playerSetsPhone = 145;
     */
    value: PlayerSetsPhone;
    case: "playerSetsPhone";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsPersonalImageUrl playerSetsPersonalImageUrl = 146;
     */
    value: PlayerSetsPersonalImageUrl;
    case: "playerSetsPersonalImageUrl";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsProfileImageUrl playerSetsProfileImageUrl = 147;
     */
    value: PlayerSetsProfileImageUrl;
    case: "playerSetsProfileImageUrl";
  } | {
    /**
     * @generated from field: gathertown.SpaceSetsCapacity spaceSetsCapacity = 148;
     */
    value: SpaceSetsCapacity;
    case: "spaceSetsCapacity";
  } | {
    /**
     * @generated from field: gathertown.SpaceOverCapacityDeniesUser spaceOverCapacityDeniesUser = 149;
     */
    value: SpaceOverCapacityDeniesUser;
    case: "spaceOverCapacityDeniesUser";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsAway playerSetsAway = 150;
     */
    value: PlayerSetsAway;
    case: "playerSetsAway";
  } | {
    /**
     * @generated from field: gathertown.MapSetCollisionsBits mapSetCollisionsBits = 151;
     */
    value: MapSetCollisionsBits;
    case: "mapSetCollisionsBits";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsCity playerSetsCity = 152;
     */
    value: PlayerSetsCity;
    case: "playerSetsCity";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsCountry playerSetsCountry = 153;
     */
    value: PlayerSetsCountry;
    case: "playerSetsCountry";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsStartDate playerSetsStartDate = 154;
     */
    value: PlayerSetsStartDate;
    case: "playerSetsStartDate";
  } | {
    /**
     * @generated from field: gathertown.PlayerStartsRecording playerStartsRecording = 156;
     */
    value: PlayerStartsRecording;
    case: "playerStartsRecording";
  } | {
    /**
     * @generated from field: gathertown.AccessRequestsUpdated accessRequestsUpdated = 157;
     */
    value: AccessRequestsUpdated;
    case: "accessRequestsUpdated";
  } | {
    /**
     * @generated from field: gathertown.AccessRequestRespondedTo accessRequestRespondedTo = 158;
     */
    value: AccessRequestRespondedTo;
    case: "accessRequestRespondedTo";
  } | {
    /**
     * @generated from field: gathertown.SpaceSetsGuestPassStatuses spaceSetsGuestPassStatuses = 159;
     */
    value: SpaceSetsGuestPassStatuses;
    case: "spaceSetsGuestPassStatuses";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsAvailability playerSetsAvailability = 160;
     */
    value: PlayerSetsAvailability;
    case: "playerSetsAvailability";
  } | {
    /**
     * @generated from field: gathertown.SubscriptionsUpdated subscriptionsUpdated = 161;
     */
    value: SubscriptionsUpdated;
    case: "subscriptionsUpdated";
  } | {
    /**
     * @generated from field: gathertown.SpaceRolePermissionOverrideUpdated spaceRolePermissionOverrideUpdated = 164;
     */
    value: SpaceRolePermissionOverrideUpdated;
    case: "spaceRolePermissionOverrideUpdated";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsLastRaisedHand playerSetsLastRaisedHand = 165;
     */
    value: PlayerSetsLastRaisedHand;
    case: "playerSetsLastRaisedHand";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsCurrentlyEquippedWearables playerSetsCurrentlyEquippedWearables = 166;
     */
    value: PlayerSetsCurrentlyEquippedWearables;
    case: "playerSetsCurrentlyEquippedWearables";
  } | {
    /**
     * @generated from field: gathertown.PlayerSetsDisplayEmail playerSetsDisplayEmail = 168;
     */
    value: PlayerSetsDisplayEmail;
    case: "playerSetsDisplayEmail";
  } | {
    /**
     * @generated from field: gathertown.MapDeleteObjectByKey mapDeleteObjectByKey = 169;
     */
    value: MapDeleteObjectByKey;
    case: "mapDeleteObjectByKey";
  } | {
    /**
     * @generated from field: gathertown.MapSetObjectsV2 mapSetObjectsV2 = 170;
     */
    value: MapSetObjectsV2;
    case: "mapSetObjectsV2";
  } | {
    /**
     * @generated from field: gathertown.PlayerInteractsWithObject playerInteractsWithObject = 171;
     */
    value: PlayerInteractsWithObject;
    case: "playerInteractsWithObject";
  } | {
    /**
     * @generated from field: gathertown.PlayerTriggersObject playerTriggersObject = 172;
     */
    value: PlayerTriggersObject;
    case: "playerTriggersObject";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.ChimeSetsUserInfo chimeSetsUserInfo = 173;
     */
    value: ChimeSetsUserInfo;
    case: "chimeSetsUserInfo";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ServerClientEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ServerClientEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 100, name: "info", kind: "message", T: Info, oneof: "event" },
    { no: 101, name: "warn", kind: "message", T: Warn, oneof: "event" },
    { no: 102, name: "error", kind: "message", T: ErrorEvent, oneof: "event" },
    { no: 103, name: "ready", kind: "message", T: Ready, oneof: "event" },
    { no: 105, name: "serverHeartbeat", kind: "message", T: ServerHeartbeat, oneof: "event" },
    { no: 107, name: "transactionStatus", kind: "message", T: TransactionStatus, oneof: "event" },
    { no: 1, name: "playerMoves", kind: "message", T: PlayerMoves, oneof: "event" },
    { no: 5, name: "playerSetsStatus", kind: "message", T: PlayerSetsStatus, oneof: "event" },
    { no: 6, name: "playerSpotlights", kind: "message", T: PlayerSpotlights, oneof: "event" },
    { no: 7, name: "playerRings", kind: "message", T: PlayerRings, oneof: "event" },
    { no: 9, name: "playerChats", kind: "message", T: PlayerChats, oneof: "event" },
    { no: 11, name: "playerGhosts", kind: "message", T: PlayerGhosts, oneof: "event" },
    { no: 12, name: "playerEntersWhisper", kind: "message", T: PlayerEntersWhisper, oneof: "event" },
    { no: 13, name: "playerLeavesWhisper", kind: "message", T: PlayerLeavesWhisper, oneof: "event" },
    { no: 14, name: "playerActivelySpeaks", kind: "message", T: PlayerActivelySpeaks, oneof: "event" },
    { no: 17, name: "playerSetsName", kind: "message", T: PlayerSetsName, oneof: "event" },
    { no: 18, name: "playerSetsTextStatus", kind: "message", T: PlayerSetsTextStatus, oneof: "event" },
    { no: 19, name: "playerSetsEmojiStatus", kind: "message", T: PlayerSetsEmojiStatus, oneof: "event" },
    { no: 20, name: "playerSetsAffiliation", kind: "message", T: PlayerSetsAffiliation, oneof: "event" },
    { no: 21, name: "playerExits", kind: "message", T: PlayerExits, oneof: "event" },
    { no: 41, name: "playerSetsIsSignedIn", kind: "message", T: PlayerSetsIsSignedIn, oneof: "event" },
    { no: 44, name: "spaceOverwrites", kind: "message", T: SpaceOverwrites, oneof: "event" },
    { no: 45, name: "spaceIsClosed", kind: "message", T: SpaceIsClosed, oneof: "event" },
    { no: 46, name: "playerEntersPortal", kind: "message", T: PlayerEntersPortal, oneof: "event" },
    { no: 47, name: "spaceSetsIdMapping", kind: "message", T: SpaceSetsIdMapping, oneof: "event" },
    { no: 48, name: "playerSetsLastActive", kind: "message", T: PlayerSetsLastActive, oneof: "event" },
    { no: 49, name: "playerShootsConfetti", kind: "message", T: PlayerShootsConfetti, oneof: "event" },
    { no: 50, name: "playerSetsEventStatus", kind: "message", T: PlayerSetsEventStatus, oneof: "event" },
    { no: 51, name: "playerSetsInConversation", kind: "message", T: PlayerSetsInConversation, oneof: "event" },
    { no: 53, name: "playerSetsCurrentArea", kind: "message", T: PlayerSetsCurrentArea, oneof: "event" },
    { no: 54, name: "playerSetsImagePointer", kind: "message", T: PlayerSetsImagePointer, oneof: "event" },
    { no: 55, name: "cookieFound", kind: "message", T: CookieFound, oneof: "event" },
    { no: 56, name: "playerEntersWhisperV2", kind: "message", T: PlayerEntersWhisperV2, oneof: "event" },
    { no: 57, name: "playerSetsGoKartId", kind: "message", T: PlayerSetsGoKartId, oneof: "event" },
    { no: 58, name: "mapSetDimensions", kind: "message", T: MapSetDimensions, oneof: "event" },
    { no: 60, name: "mapSetBackgroundImagePath", kind: "message", T: MapSetBackgroundImagePath, oneof: "event" },
    { no: 61, name: "mapSetForegroundImagePath", kind: "message", T: MapSetForegroundImagePath, oneof: "event" },
    { no: 64, name: "mapSetSpawns", kind: "message", T: MapSetSpawns, oneof: "event" },
    { no: 65, name: "mapSetPortals", kind: "message", T: MapSetPortals, oneof: "event" },
    { no: 66, name: "mapSetAnnouncer", kind: "message", T: MapSetAnnouncer, oneof: "event" },
    { no: 69, name: "mapSetAssets", kind: "message", T: MapSetAssets, oneof: "event" },
    { no: 71, name: "mapSetName", kind: "message", T: MapSetName, oneof: "event" },
    { no: 73, name: "mapSetMuteOnEntry", kind: "message", T: MapSetMuteOnEntry, oneof: "event" },
    { no: 74, name: "mapSetUseDrawnBG", kind: "message", T: MapSetUseDrawnBG, oneof: "event" },
    { no: 75, name: "mapSetWalls", kind: "message", T: MapSetWalls, oneof: "event" },
    { no: 76, name: "mapSetFloors", kind: "message", T: MapSetFloors, oneof: "event" },
    { no: 77, name: "mapSetAreas", kind: "message", T: MapSetAreas, oneof: "event" },
    { no: 79, name: "mapSetSpawn", kind: "message", T: MapSetSpawn, oneof: "event" },
    { no: 80, name: "playerSetsIsAlone", kind: "message", T: PlayerSetsIsAlone, oneof: "event" },
    { no: 81, name: "playerJoins", kind: "message", T: PlayerJoins, oneof: "event" },
    { no: 82, name: "mapSetEnabledChats", kind: "message", T: MapSetEnabledChats, oneof: "event" },
    { no: 83, name: "mapSetDescription", kind: "message", T: MapSetDescription, oneof: "event" },
    { no: 84, name: "mapSetDecoration", kind: "message", T: MapSetDecoration, oneof: "event" },
    { no: 85, name: "mapSetTutorialTasks", kind: "message", T: MapSetTutorialTasks, oneof: "event" },
    { no: 86, name: "mapSetMiniMapImagePath", kind: "message", T: MapSetMiniMapImagePath, oneof: "event" },
    { no: 87, name: "spacePlaysSound", kind: "message", T: SpacePlaysSound, oneof: "event" },
    { no: 88, name: "mapSetScript", kind: "message", T: MapSetScript, oneof: "event" },
    { no: 90, name: "playerSetsIsMobile", kind: "message", T: PlayerSetsIsMobile, oneof: "event" },
    { no: 91, name: "setScreenPointerServer", kind: "message", T: SetScreenPointerServer, oneof: "event" },
    { no: 92, name: "playerSetsEmoteV2", kind: "message", T: PlayerSetsEmoteV2, oneof: "event" },
    { no: 93, name: "playerSetsFocusModeEndTime", kind: "message", T: PlayerSetsFocusModeEndTime, oneof: "event" },
    { no: 94, name: "spaceSetsSpaceMembers", kind: "message", T: SpaceSetsSpaceMembers, oneof: "event" },
    { no: 167, name: "spaceSetsSpaceUsers", kind: "message", T: SpaceSetsSpaceUsers, oneof: "event" },
    { no: 95, name: "customEvent", kind: "message", T: CustomEvent, oneof: "event" },
    { no: 97, name: "playerBlocks", kind: "message", T: PlayerBlocks, oneof: "event" },
    { no: 98, name: "playerUpdatesFocusModeStatus", kind: "message", T: PlayerUpdatesFocusModeStatus, oneof: "event" },
    { no: 99, name: "playerNotifies", kind: "message", T: PlayerNotifies, oneof: "event" },
    { no: 108, name: "playerSetsItemString", kind: "message", T: PlayerSetsItemString, oneof: "event" },
    { no: 110, name: "playerSetsFollowTarget", kind: "message", T: PlayerSetsFollowTarget, oneof: "event" },
    { no: 111, name: "playerRequestsToLead", kind: "message", T: PlayerRequestsToLead, oneof: "event" },
    { no: 112, name: "playerSetsManualVideoSrc", kind: "message", T: PlayerSetsManualVideoSrc, oneof: "event" },
    { no: 113, name: "playerSetsIsNpc", kind: "message", T: PlayerSetsIsNpc, oneof: "event" },
    { no: 114, name: "playerSetsSubtitle", kind: "message", T: PlayerSetsSubtitle, oneof: "event" },
    { no: 115, name: "mapCommitsChanges", kind: "message", T: MapCommitsChanges, oneof: "event" },
    { no: 117, name: "mapMoveObject", kind: "message", T: MapMoveObject, oneof: "event" },
    { no: 118, name: "playerEditsChatMessage", kind: "message", T: PlayerEditsChatMessage, oneof: "event" },
    { no: 119, name: "fxShakeObject", kind: "message", T: FXShakeObject, oneof: "event" },
    { no: 120, name: "fxShakeCamera", kind: "message", T: FXShakeCamera, oneof: "event" },
    { no: 121, name: "playerSendsCommand", kind: "message", T: PlayerSendsCommand, oneof: "event" },
    { no: 122, name: "spaceRegistersCommand", kind: "message", T: SpaceRegistersCommand, oneof: "event" },
    { no: 123, name: "speakerUpdatesSession", kind: "message", T: SpeakerUpdatesSession, oneof: "event" },
    { no: 124, name: "playerUpdatesInventory", kind: "message", T: PlayerUpdatesInventory, oneof: "event" },
    { no: 125, name: "spaceUpdatesItems", kind: "message", T: SpaceUpdatesItems, oneof: "event" },
    { no: 126, name: "playerSetsVehicleId", kind: "message", T: PlayerSetsVehicleId, oneof: "event" },
    { no: 127, name: "playerSetsSpeedModifier", kind: "message", T: PlayerSetsSpeedModifier, oneof: "event" },
    { no: 128, name: "playerHighFives", kind: "message", T: PlayerHighFives, oneof: "event" },
    { no: 130, name: "spaceStopsSound", kind: "message", T: SpaceStopsSound, oneof: "event" },
    { no: 131, name: "hipToBeSquare", kind: "message", T: HipToBeSquare, oneof: "event" },
    { no: 132, name: "playerCrafts", kind: "message", T: PlayerCrafts, oneof: "event" },
    { no: 133, name: "playerTriggersInventoryItem", kind: "message", T: PlayerTriggersInventoryItem, oneof: "event" },
    { no: 134, name: "playerSetsAllowScreenPointer", kind: "message", T: PlayerSetsAllowScreenPointer, oneof: "event" },
    { no: 135, name: "precomputedEnterLocation", kind: "message", T: PrecomputedEnterLocation, oneof: "event" },
    { no: 136, name: "gotRequestMute", kind: "message", T: GotRequestMute, oneof: "event" },
    { no: 137, name: "playerSetsDeskInfo", kind: "message", T: PlayerSetsDeskInfo, oneof: "event" },
    { no: 138, name: "mapSetNooks", kind: "message", T: MapSetNooks, oneof: "event" },
    { no: 139, name: "dynamicGates", kind: "message", T: DynamicGates, oneof: "event" },
    { no: 140, name: "playerWaves", kind: "message", T: PlayerWaves, oneof: "event" },
    { no: 141, name: "playerSetsPronouns", kind: "message", T: PlayerSetsPronouns, oneof: "event" },
    { no: 142, name: "playerSetsTitle", kind: "message", T: PlayerSetsTitle, oneof: "event" },
    { no: 143, name: "playerSetsTimezone", kind: "message", T: PlayerSetsTimezone, oneof: "event" },
    { no: 144, name: "playerSetsDescription", kind: "message", T: PlayerSetsDescription, oneof: "event" },
    { no: 145, name: "playerSetsPhone", kind: "message", T: PlayerSetsPhone, oneof: "event" },
    { no: 146, name: "playerSetsPersonalImageUrl", kind: "message", T: PlayerSetsPersonalImageUrl, oneof: "event" },
    { no: 147, name: "playerSetsProfileImageUrl", kind: "message", T: PlayerSetsProfileImageUrl, oneof: "event" },
    { no: 148, name: "spaceSetsCapacity", kind: "message", T: SpaceSetsCapacity, oneof: "event" },
    { no: 149, name: "spaceOverCapacityDeniesUser", kind: "message", T: SpaceOverCapacityDeniesUser, oneof: "event" },
    { no: 150, name: "playerSetsAway", kind: "message", T: PlayerSetsAway, oneof: "event" },
    { no: 151, name: "mapSetCollisionsBits", kind: "message", T: MapSetCollisionsBits, oneof: "event" },
    { no: 152, name: "playerSetsCity", kind: "message", T: PlayerSetsCity, oneof: "event" },
    { no: 153, name: "playerSetsCountry", kind: "message", T: PlayerSetsCountry, oneof: "event" },
    { no: 154, name: "playerSetsStartDate", kind: "message", T: PlayerSetsStartDate, oneof: "event" },
    { no: 156, name: "playerStartsRecording", kind: "message", T: PlayerStartsRecording, oneof: "event" },
    { no: 157, name: "accessRequestsUpdated", kind: "message", T: AccessRequestsUpdated, oneof: "event" },
    { no: 158, name: "accessRequestRespondedTo", kind: "message", T: AccessRequestRespondedTo, oneof: "event" },
    { no: 159, name: "spaceSetsGuestPassStatuses", kind: "message", T: SpaceSetsGuestPassStatuses, oneof: "event" },
    { no: 160, name: "playerSetsAvailability", kind: "message", T: PlayerSetsAvailability, oneof: "event" },
    { no: 161, name: "subscriptionsUpdated", kind: "message", T: SubscriptionsUpdated, oneof: "event" },
    { no: 164, name: "spaceRolePermissionOverrideUpdated", kind: "message", T: SpaceRolePermissionOverrideUpdated, oneof: "event" },
    { no: 165, name: "playerSetsLastRaisedHand", kind: "message", T: PlayerSetsLastRaisedHand, oneof: "event" },
    { no: 166, name: "playerSetsCurrentlyEquippedWearables", kind: "message", T: PlayerSetsCurrentlyEquippedWearables, oneof: "event" },
    { no: 168, name: "playerSetsDisplayEmail", kind: "message", T: PlayerSetsDisplayEmail, oneof: "event" },
    { no: 169, name: "mapDeleteObjectByKey", kind: "message", T: MapDeleteObjectByKey, oneof: "event" },
    { no: 170, name: "mapSetObjectsV2", kind: "message", T: MapSetObjectsV2, oneof: "event" },
    { no: 171, name: "playerInteractsWithObject", kind: "message", T: PlayerInteractsWithObject, oneof: "event" },
    { no: 172, name: "playerTriggersObject", kind: "message", T: PlayerTriggersObject, oneof: "event" },
    { no: 173, name: "chimeSetsUserInfo", kind: "message", T: ChimeSetsUserInfo, oneof: "event" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerClientEvent {
    return new ServerClientEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerClientEvent {
    return new ServerClientEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerClientEvent {
    return new ServerClientEvent().fromJsonString(jsonString, options);
  }

  static equals(a: ServerClientEvent | PlainMessage<ServerClientEvent> | undefined, b: ServerClientEvent | PlainMessage<ServerClientEvent> | undefined): boolean {
    return proto3.util.equals(ServerClientEvent, a, b);
  }
}

/**
 * the events the client is subscribed to has been changed on the server
 *
 * @generated from message gathertown.SubscriptionsUpdated
 */
export class SubscriptionsUpdated extends Message<SubscriptionsUpdated> {
  /**
   * array of event names the client will be notified about
   *
   * @generated from field: repeated string subscriptions = 1;
   */
  subscriptions: string[] = [];

  constructor(data?: PartialMessage<SubscriptionsUpdated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SubscriptionsUpdated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscriptions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscriptionsUpdated {
    return new SubscriptionsUpdated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscriptionsUpdated {
    return new SubscriptionsUpdated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscriptionsUpdated {
    return new SubscriptionsUpdated().fromJsonString(jsonString, options);
  }

  static equals(a: SubscriptionsUpdated | PlainMessage<SubscriptionsUpdated> | undefined, b: SubscriptionsUpdated | PlainMessage<SubscriptionsUpdated> | undefined): boolean {
    return proto3.util.equals(SubscriptionsUpdated, a, b);
  }
}

/**
 * @generated from message gathertown.ServerHeartbeat
 */
export class ServerHeartbeat extends Message<ServerHeartbeat> {
  /**
   * no longer used
   *
   * @generated from field: uint32 lastRTT = 1;
   */
  lastRTT = 0;

  constructor(data?: PartialMessage<ServerHeartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ServerHeartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lastRTT", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerHeartbeat {
    return new ServerHeartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerHeartbeat {
    return new ServerHeartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerHeartbeat {
    return new ServerHeartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: ServerHeartbeat | PlainMessage<ServerHeartbeat> | undefined, b: ServerHeartbeat | PlainMessage<ServerHeartbeat> | undefined): boolean {
    return proto3.util.equals(ServerHeartbeat, a, b);
  }
}

/**
 * @generated from message gathertown.Info
 */
export class Info extends Message<Info> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<Info>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Info";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info {
    return new Info().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info {
    return new Info().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info {
    return new Info().fromJsonString(jsonString, options);
  }

  static equals(a: Info | PlainMessage<Info> | undefined, b: Info | PlainMessage<Info> | undefined): boolean {
    return proto3.util.equals(Info, a, b);
  }
}

/**
 * @generated from message gathertown.Warn
 */
export class Warn extends Message<Warn> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<Warn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Warn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Warn {
    return new Warn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Warn {
    return new Warn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Warn {
    return new Warn().fromJsonString(jsonString, options);
  }

  static equals(a: Warn | PlainMessage<Warn> | undefined, b: Warn | PlainMessage<Warn> | undefined): boolean {
    return proto3.util.equals(Warn, a, b);
  }
}

/**
 * @generated from message gathertown.ErrorEvent
 */
export class ErrorEvent extends Message<ErrorEvent> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: uint32 code = 2;
   */
  code = 0;

  constructor(data?: PartialMessage<ErrorEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ErrorEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "code", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorEvent {
    return new ErrorEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorEvent {
    return new ErrorEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorEvent {
    return new ErrorEvent().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorEvent | PlainMessage<ErrorEvent> | undefined, b: ErrorEvent | PlainMessage<ErrorEvent> | undefined): boolean {
    return proto3.util.equals(ErrorEvent, a, b);
  }
}

/**
 * @generated from message gathertown.Ready
 */
export class Ready extends Message<Ready> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<Ready>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Ready";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ready {
    return new Ready().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ready {
    return new Ready().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ready {
    return new Ready().fromJsonString(jsonString, options);
  }

  static equals(a: Ready | PlainMessage<Ready> | undefined, b: Ready | PlainMessage<Ready> | undefined): boolean {
    return proto3.util.equals(Ready, a, b);
  }
}

/**
 * @generated from message gathertown.TransactionStatus
 */
export class TransactionStatus extends Message<TransactionStatus> {
  /**
   * @generated from field: uint32 txnId = 1;
   */
  txnId = 0;

  /**
   * @generated from field: bool succeeded = 2;
   */
  succeeded = false;

  /**
   * @generated from field: optional string reason = 3;
   */
  reason?: string;

  constructor(data?: PartialMessage<TransactionStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.TransactionStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "txnId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "succeeded", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionStatus {
    return new TransactionStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionStatus {
    return new TransactionStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionStatus {
    return new TransactionStatus().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionStatus | PlainMessage<TransactionStatus> | undefined, b: TransactionStatus | PlainMessage<TransactionStatus> | undefined): boolean {
    return proto3.util.equals(TransactionStatus, a, b);
  }
}

/**
 * Always sent as the first message about any given player. If there are fields that must be initialized on clients
 * immediately, they should be included in this message.
 *
 * @generated from message gathertown.PlayerJoins
 */
export class PlayerJoins extends Message<PlayerJoins> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  constructor(data?: PartialMessage<PlayerJoins>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerJoins";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerJoins {
    return new PlayerJoins().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerJoins {
    return new PlayerJoins().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerJoins {
    return new PlayerJoins().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerJoins | PlainMessage<PlayerJoins> | undefined, b: PlayerJoins | PlainMessage<PlayerJoins> | undefined): boolean {
    return proto3.util.equals(PlayerJoins, a, b);
  }
}

/**
 * @generated from message gathertown.GotRequestMute
 */
export class GotRequestMute extends Message<GotRequestMute> {
  /**
   * @generated from field: string muterId = 1;
   */
  muterId = "";

  /**
   * @generated from field: bool video = 2;
   */
  video = false;

  constructor(data?: PartialMessage<GotRequestMute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.GotRequestMute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "muterId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "video", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GotRequestMute {
    return new GotRequestMute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GotRequestMute {
    return new GotRequestMute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GotRequestMute {
    return new GotRequestMute().fromJsonString(jsonString, options);
  }

  static equals(a: GotRequestMute | PlainMessage<GotRequestMute> | undefined, b: GotRequestMute | PlainMessage<GotRequestMute> | undefined): boolean {
    return proto3.util.equals(GotRequestMute, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerMoves
 */
export class PlayerMoves extends Message<PlayerMoves> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * all optional, only send what's changed
   *
   * @generated from field: optional uint32 x = 2;
   */
  x?: number;

  /**
   * @generated from field: optional uint32 y = 3;
   */
  y?: number;

  /**
   * @generated from field: optional gathertown.SpriteDirectionEnum.ENUM direction = 4;
   */
  direction?: SpriteDirectionEnum_ENUM;

  /**
   * @generated from field: optional string mapId = 5;
   */
  mapId?: string;

  /**
   * @generated from field: uint32 lastInputId = 6;
   */
  lastInputId = 0;

  constructor(data?: PartialMessage<PlayerMoves>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerMoves";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 3, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 4, name: "direction", kind: "enum", T: proto3.getEnumType(SpriteDirectionEnum_ENUM), opt: true },
    { no: 5, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "lastInputId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerMoves {
    return new PlayerMoves().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerMoves {
    return new PlayerMoves().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerMoves {
    return new PlayerMoves().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerMoves | PlainMessage<PlayerMoves> | undefined, b: PlayerMoves | PlainMessage<PlayerMoves> | undefined): boolean {
    return proto3.util.equals(PlayerMoves, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsStatus
 */
export class PlayerSetsStatus extends Message<PlayerSetsStatus> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool busy = 2;
   */
  busy = false;

  constructor(data?: PartialMessage<PlayerSetsStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "busy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsStatus {
    return new PlayerSetsStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsStatus {
    return new PlayerSetsStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsStatus {
    return new PlayerSetsStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsStatus | PlainMessage<PlayerSetsStatus> | undefined, b: PlayerSetsStatus | PlainMessage<PlayerSetsStatus> | undefined): boolean {
    return proto3.util.equals(PlayerSetsStatus, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsAvailability
 */
export class PlayerSetsAvailability extends Message<PlayerSetsAvailability> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string status = 2;
   */
  status = "";

  /**
   * @generated from field: optional string statusUpdatedAt = 3;
   */
  statusUpdatedAt?: string;

  /**
   * @generated from field: optional string statusEndOption = 4;
   */
  statusEndOption?: string;

  constructor(data?: PartialMessage<PlayerSetsAvailability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsAvailability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "status", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "statusUpdatedAt", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "statusEndOption", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsAvailability {
    return new PlayerSetsAvailability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsAvailability {
    return new PlayerSetsAvailability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsAvailability {
    return new PlayerSetsAvailability().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsAvailability | PlainMessage<PlayerSetsAvailability> | undefined, b: PlayerSetsAvailability | PlainMessage<PlayerSetsAvailability> | undefined): boolean {
    return proto3.util.equals(PlayerSetsAvailability, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSpotlights
 */
export class PlayerSpotlights extends Message<PlayerSpotlights> {
  /**
   * the person who is being spotlit
   *
   * @generated from field: uint32 encId = 2;
   */
  encId = 0;

  /**
   * the person who is doing the spotlighting; legacy \holdover
   *
   * @generated from field: uint32 spotlightedBy = 1;
   */
  spotlightedBy = 0;

  /**
   * @generated from field: uint32 spotlighted = 3;
   */
  spotlighted = 0;

  constructor(data?: PartialMessage<PlayerSpotlights>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSpotlights";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 1, name: "spotlightedBy", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "spotlighted", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSpotlights {
    return new PlayerSpotlights().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSpotlights {
    return new PlayerSpotlights().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSpotlights {
    return new PlayerSpotlights().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSpotlights | PlainMessage<PlayerSpotlights> | undefined, b: PlayerSpotlights | PlainMessage<PlayerSpotlights> | undefined): boolean {
    return proto3.util.equals(PlayerSpotlights, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerRings
 */
export class PlayerRings extends Message<PlayerRings> {
  /**
   * the ringer
   *
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  constructor(data?: PartialMessage<PlayerRings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerRings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerRings {
    return new PlayerRings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerRings {
    return new PlayerRings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerRings {
    return new PlayerRings().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerRings | PlainMessage<PlayerRings> | undefined, b: PlayerRings | PlainMessage<PlayerRings> | undefined): boolean {
    return proto3.util.equals(PlayerRings, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsImagePointer
 */
export class PlayerSetsImagePointer extends Message<PlayerSetsImagePointer> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string objectId = 2;
   */
  objectId = "";

  /**
   * @generated from field: double x = 3;
   */
  x = 0;

  /**
   * @generated from field: double y = 4;
   */
  y = 0;

  constructor(data?: PartialMessage<PlayerSetsImagePointer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsImagePointer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "objectId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsImagePointer {
    return new PlayerSetsImagePointer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsImagePointer {
    return new PlayerSetsImagePointer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsImagePointer {
    return new PlayerSetsImagePointer().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsImagePointer | PlainMessage<PlayerSetsImagePointer> | undefined, b: PlayerSetsImagePointer | PlainMessage<PlayerSetsImagePointer> | undefined): boolean {
    return proto3.util.equals(PlayerSetsImagePointer, a, b);
  }
}

/**
 * @generated from message gathertown.SetScreenPointerServer
 */
export class SetScreenPointerServer extends Message<SetScreenPointerServer> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string screenId = 2;
   */
  screenId = "";

  /**
   * @generated from field: double x = 3;
   */
  x = 0;

  /**
   * @generated from field: double y = 4;
   */
  y = 0;

  /**
   * @generated from field: string color = 5;
   */
  color = "";

  constructor(data?: PartialMessage<SetScreenPointerServer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetScreenPointerServer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "screenId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "color", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetScreenPointerServer {
    return new SetScreenPointerServer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetScreenPointerServer {
    return new SetScreenPointerServer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetScreenPointerServer {
    return new SetScreenPointerServer().fromJsonString(jsonString, options);
  }

  static equals(a: SetScreenPointerServer | PlainMessage<SetScreenPointerServer> | undefined, b: SetScreenPointerServer | PlainMessage<SetScreenPointerServer> | undefined): boolean {
    return proto3.util.equals(SetScreenPointerServer, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerChats
 */
export class PlayerChats extends Message<PlayerChats> {
  /**
   * @generated from field: string senderId = 1;
   */
  senderId = "";

  /**
   * @generated from field: string recipient = 2;
   */
  recipient = "";

  /**
   * @generated from field: string contents = 3;
   */
  contents = "";

  /**
   * @generated from field: string senderName = 4;
   */
  senderName = "";

  /**
   * deprecating (NGN-710)
   *
   * @generated from field: optional gathertown.Timestamp timestamp = 5;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: string messageType = 6;
   */
  messageType = "";

  /**
   * @generated from field: double unixTime = 7;
   */
  unixTime = 0;

  /**
   * @generated from field: optional string id = 8;
   */
  id?: string;

  /**
   * @generated from field: optional string roomId = 9;
   */
  roomId?: string;

  /**
   * @generated from field: optional bool approved = 10;
   */
  approved?: boolean;

  /**
   * @generated from field: optional string nookId = 11;
   */
  nookId?: string;

  constructor(data?: PartialMessage<PlayerChats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerChats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "senderId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "recipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "senderName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "timestamp", kind: "message", T: Timestamp, opt: true },
    { no: 6, name: "messageType", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "unixTime", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 8, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 9, name: "roomId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "approved", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 11, name: "nookId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerChats {
    return new PlayerChats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerChats {
    return new PlayerChats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerChats {
    return new PlayerChats().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerChats | PlainMessage<PlayerChats> | undefined, b: PlayerChats | PlainMessage<PlayerChats> | undefined): boolean {
    return proto3.util.equals(PlayerChats, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerWaves
 */
export class PlayerWaves extends Message<PlayerWaves> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string targetId = 2;
   */
  targetId = "";

  /**
   * @generated from field: bool isReply = 3;
   */
  isReply = false;

  constructor(data?: PartialMessage<PlayerWaves>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerWaves";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isReply", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerWaves {
    return new PlayerWaves().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerWaves {
    return new PlayerWaves().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerWaves {
    return new PlayerWaves().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerWaves | PlainMessage<PlayerWaves> | undefined, b: PlayerWaves | PlainMessage<PlayerWaves> | undefined): boolean {
    return proto3.util.equals(PlayerWaves, a, b);
  }
}

/**
 * deprecating this (NGN-710)
 *
 * @generated from message gathertown.Timestamp
 */
export class Timestamp extends Message<Timestamp> {
  /**
   * @generated from field: float seconds = 1;
   */
  seconds = 0;

  /**
   * @generated from field: float nanoseconds = 2;
   */
  nanoseconds = 0;

  constructor(data?: PartialMessage<Timestamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Timestamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "seconds", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "nanoseconds", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Timestamp {
    return new Timestamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Timestamp {
    return new Timestamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Timestamp {
    return new Timestamp().fromJsonString(jsonString, options);
  }

  static equals(a: Timestamp | PlainMessage<Timestamp> | undefined, b: Timestamp | PlainMessage<Timestamp> | undefined): boolean {
    return proto3.util.equals(Timestamp, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerInteractsWithObject
 */
export class PlayerInteractsWithObject extends Message<PlayerInteractsWithObject> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string mapId = 2;
   */
  mapId = "";

  /**
   * @generated from field: string key = 3;
   */
  key = "";

  /**
   * JSON string
   *
   * @generated from field: optional string dataJson = 4;
   */
  dataJson?: string;

  constructor(data?: PartialMessage<PlayerInteractsWithObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerInteractsWithObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "dataJson", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerInteractsWithObject {
    return new PlayerInteractsWithObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerInteractsWithObject {
    return new PlayerInteractsWithObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerInteractsWithObject {
    return new PlayerInteractsWithObject().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerInteractsWithObject | PlainMessage<PlayerInteractsWithObject> | undefined, b: PlayerInteractsWithObject | PlainMessage<PlayerInteractsWithObject> | undefined): boolean {
    return proto3.util.equals(PlayerInteractsWithObject, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerGhosts
 */
export class PlayerGhosts extends Message<PlayerGhosts> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: uint32 ghost = 2;
   */
  ghost = 0;

  constructor(data?: PartialMessage<PlayerGhosts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerGhosts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "ghost", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerGhosts {
    return new PlayerGhosts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerGhosts {
    return new PlayerGhosts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerGhosts {
    return new PlayerGhosts().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerGhosts | PlainMessage<PlayerGhosts> | undefined, b: PlayerGhosts | PlainMessage<PlayerGhosts> | undefined): boolean {
    return proto3.util.equals(PlayerGhosts, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerEntersWhisper
 */
export class PlayerEntersWhisper extends Message<PlayerEntersWhisper> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string whisperRecipient = 2;
   */
  whisperRecipient = "";

  /**
   * @generated from field: string whisperId = 3;
   */
  whisperId = "";

  constructor(data?: PartialMessage<PlayerEntersWhisper>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerEntersWhisper";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "whisperRecipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "whisperId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerEntersWhisper {
    return new PlayerEntersWhisper().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerEntersWhisper {
    return new PlayerEntersWhisper().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerEntersWhisper {
    return new PlayerEntersWhisper().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerEntersWhisper | PlainMessage<PlayerEntersWhisper> | undefined, b: PlayerEntersWhisper | PlainMessage<PlayerEntersWhisper> | undefined): boolean {
    return proto3.util.equals(PlayerEntersWhisper, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerEntersWhisperV2
 */
export class PlayerEntersWhisperV2 extends Message<PlayerEntersWhisperV2> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * the person you intend to be whispering; will apply whisperId property to them as well
   *
   * @generated from field: uint32 encIdTarget = 2;
   */
  encIdTarget = 0;

  /**
   * @generated from field: string whisperId = 3;
   */
  whisperId = "";

  constructor(data?: PartialMessage<PlayerEntersWhisperV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerEntersWhisperV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "encIdTarget", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "whisperId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerEntersWhisperV2 {
    return new PlayerEntersWhisperV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerEntersWhisperV2 {
    return new PlayerEntersWhisperV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerEntersWhisperV2 {
    return new PlayerEntersWhisperV2().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerEntersWhisperV2 | PlainMessage<PlayerEntersWhisperV2> | undefined, b: PlayerEntersWhisperV2 | PlainMessage<PlayerEntersWhisperV2> | undefined): boolean {
    return proto3.util.equals(PlayerEntersWhisperV2, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerLeavesWhisper
 */
export class PlayerLeavesWhisper extends Message<PlayerLeavesWhisper> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  constructor(data?: PartialMessage<PlayerLeavesWhisper>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerLeavesWhisper";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerLeavesWhisper {
    return new PlayerLeavesWhisper().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerLeavesWhisper {
    return new PlayerLeavesWhisper().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerLeavesWhisper {
    return new PlayerLeavesWhisper().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerLeavesWhisper | PlainMessage<PlayerLeavesWhisper> | undefined, b: PlayerLeavesWhisper | PlainMessage<PlayerLeavesWhisper> | undefined): boolean {
    return proto3.util.equals(PlayerLeavesWhisper, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerActivelySpeaks
 */
export class PlayerActivelySpeaks extends Message<PlayerActivelySpeaks> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: uint32 activelySpeaking = 2;
   */
  activelySpeaking = 0;

  constructor(data?: PartialMessage<PlayerActivelySpeaks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerActivelySpeaks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "activelySpeaking", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerActivelySpeaks {
    return new PlayerActivelySpeaks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerActivelySpeaks {
    return new PlayerActivelySpeaks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerActivelySpeaks {
    return new PlayerActivelySpeaks().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerActivelySpeaks | PlainMessage<PlayerActivelySpeaks> | undefined, b: PlayerActivelySpeaks | PlainMessage<PlayerActivelySpeaks> | undefined): boolean {
    return proto3.util.equals(PlayerActivelySpeaks, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsEmoteV2
 */
export class PlayerSetsEmoteV2 extends Message<PlayerSetsEmoteV2> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: optional string emote = 2;
   */
  emote?: string;

  /**
   * @generated from field: optional uint32 count = 3;
   */
  count?: number;

  constructor(data?: PartialMessage<PlayerSetsEmoteV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsEmoteV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "emote", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsEmoteV2 {
    return new PlayerSetsEmoteV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsEmoteV2 {
    return new PlayerSetsEmoteV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsEmoteV2 {
    return new PlayerSetsEmoteV2().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsEmoteV2 | PlainMessage<PlayerSetsEmoteV2> | undefined, b: PlayerSetsEmoteV2 | PlainMessage<PlayerSetsEmoteV2> | undefined): boolean {
    return proto3.util.equals(PlayerSetsEmoteV2, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsLastRaisedHand
 */
export class PlayerSetsLastRaisedHand extends Message<PlayerSetsLastRaisedHand> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string lastRaisedHand = 2;
   */
  lastRaisedHand = "";

  constructor(data?: PartialMessage<PlayerSetsLastRaisedHand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsLastRaisedHand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "lastRaisedHand", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsLastRaisedHand {
    return new PlayerSetsLastRaisedHand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsLastRaisedHand {
    return new PlayerSetsLastRaisedHand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsLastRaisedHand {
    return new PlayerSetsLastRaisedHand().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsLastRaisedHand | PlainMessage<PlayerSetsLastRaisedHand> | undefined, b: PlayerSetsLastRaisedHand | PlainMessage<PlayerSetsLastRaisedHand> | undefined): boolean {
    return proto3.util.equals(PlayerSetsLastRaisedHand, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsLastActive
 */
export class PlayerSetsLastActive extends Message<PlayerSetsLastActive> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string lastActive = 2;
   */
  lastActive = "";

  constructor(data?: PartialMessage<PlayerSetsLastActive>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsLastActive";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "lastActive", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsLastActive {
    return new PlayerSetsLastActive().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsLastActive {
    return new PlayerSetsLastActive().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsLastActive {
    return new PlayerSetsLastActive().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsLastActive | PlainMessage<PlayerSetsLastActive> | undefined, b: PlayerSetsLastActive | PlainMessage<PlayerSetsLastActive> | undefined): boolean {
    return proto3.util.equals(PlayerSetsLastActive, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsName
 */
export class PlayerSetsName extends Message<PlayerSetsName> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<PlayerSetsName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsName";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsName {
    return new PlayerSetsName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsName {
    return new PlayerSetsName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsName {
    return new PlayerSetsName().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsName | PlainMessage<PlayerSetsName> | undefined, b: PlayerSetsName | PlainMessage<PlayerSetsName> | undefined): boolean {
    return proto3.util.equals(PlayerSetsName, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsTextStatus
 */
export class PlayerSetsTextStatus extends Message<PlayerSetsTextStatus> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string textStatus = 2;
   */
  textStatus = "";

  constructor(data?: PartialMessage<PlayerSetsTextStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsTextStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "textStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsTextStatus {
    return new PlayerSetsTextStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsTextStatus {
    return new PlayerSetsTextStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsTextStatus {
    return new PlayerSetsTextStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsTextStatus | PlainMessage<PlayerSetsTextStatus> | undefined, b: PlayerSetsTextStatus | PlainMessage<PlayerSetsTextStatus> | undefined): boolean {
    return proto3.util.equals(PlayerSetsTextStatus, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsPronouns
 */
export class PlayerSetsPronouns extends Message<PlayerSetsPronouns> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string pronouns = 2;
   */
  pronouns = "";

  constructor(data?: PartialMessage<PlayerSetsPronouns>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsPronouns";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "pronouns", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsPronouns {
    return new PlayerSetsPronouns().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsPronouns {
    return new PlayerSetsPronouns().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsPronouns {
    return new PlayerSetsPronouns().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsPronouns | PlainMessage<PlayerSetsPronouns> | undefined, b: PlayerSetsPronouns | PlainMessage<PlayerSetsPronouns> | undefined): boolean {
    return proto3.util.equals(PlayerSetsPronouns, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsTitle
 */
export class PlayerSetsTitle extends Message<PlayerSetsTitle> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string title = 2;
   */
  title = "";

  constructor(data?: PartialMessage<PlayerSetsTitle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsTitle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsTitle {
    return new PlayerSetsTitle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsTitle {
    return new PlayerSetsTitle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsTitle {
    return new PlayerSetsTitle().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsTitle | PlainMessage<PlayerSetsTitle> | undefined, b: PlayerSetsTitle | PlainMessage<PlayerSetsTitle> | undefined): boolean {
    return proto3.util.equals(PlayerSetsTitle, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsCity
 */
export class PlayerSetsCity extends Message<PlayerSetsCity> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string city = 2;
   */
  city = "";

  constructor(data?: PartialMessage<PlayerSetsCity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsCity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "city", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsCity {
    return new PlayerSetsCity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsCity {
    return new PlayerSetsCity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsCity {
    return new PlayerSetsCity().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsCity | PlainMessage<PlayerSetsCity> | undefined, b: PlayerSetsCity | PlainMessage<PlayerSetsCity> | undefined): boolean {
    return proto3.util.equals(PlayerSetsCity, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsCountry
 */
export class PlayerSetsCountry extends Message<PlayerSetsCountry> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string country = 2;
   */
  country = "";

  constructor(data?: PartialMessage<PlayerSetsCountry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsCountry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsCountry {
    return new PlayerSetsCountry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsCountry {
    return new PlayerSetsCountry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsCountry {
    return new PlayerSetsCountry().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsCountry | PlainMessage<PlayerSetsCountry> | undefined, b: PlayerSetsCountry | PlainMessage<PlayerSetsCountry> | undefined): boolean {
    return proto3.util.equals(PlayerSetsCountry, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsStartDate
 */
export class PlayerSetsStartDate extends Message<PlayerSetsStartDate> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string startDate = 2;
   */
  startDate = "";

  constructor(data?: PartialMessage<PlayerSetsStartDate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsStartDate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "startDate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsStartDate {
    return new PlayerSetsStartDate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsStartDate {
    return new PlayerSetsStartDate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsStartDate {
    return new PlayerSetsStartDate().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsStartDate | PlainMessage<PlayerSetsStartDate> | undefined, b: PlayerSetsStartDate | PlainMessage<PlayerSetsStartDate> | undefined): boolean {
    return proto3.util.equals(PlayerSetsStartDate, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsTimezone
 */
export class PlayerSetsTimezone extends Message<PlayerSetsTimezone> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string timezone = 2;
   */
  timezone = "";

  constructor(data?: PartialMessage<PlayerSetsTimezone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsTimezone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "timezone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsTimezone {
    return new PlayerSetsTimezone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsTimezone {
    return new PlayerSetsTimezone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsTimezone {
    return new PlayerSetsTimezone().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsTimezone | PlainMessage<PlayerSetsTimezone> | undefined, b: PlayerSetsTimezone | PlainMessage<PlayerSetsTimezone> | undefined): boolean {
    return proto3.util.equals(PlayerSetsTimezone, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsPhone
 */
export class PlayerSetsPhone extends Message<PlayerSetsPhone> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string phone = 2;
   */
  phone = "";

  constructor(data?: PartialMessage<PlayerSetsPhone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsPhone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "phone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsPhone {
    return new PlayerSetsPhone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsPhone {
    return new PlayerSetsPhone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsPhone {
    return new PlayerSetsPhone().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsPhone | PlainMessage<PlayerSetsPhone> | undefined, b: PlayerSetsPhone | PlainMessage<PlayerSetsPhone> | undefined): boolean {
    return proto3.util.equals(PlayerSetsPhone, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsDisplayEmail
 */
export class PlayerSetsDisplayEmail extends Message<PlayerSetsDisplayEmail> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string displayEmail = 2;
   */
  displayEmail = "";

  constructor(data?: PartialMessage<PlayerSetsDisplayEmail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsDisplayEmail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "displayEmail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsDisplayEmail {
    return new PlayerSetsDisplayEmail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsDisplayEmail {
    return new PlayerSetsDisplayEmail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsDisplayEmail {
    return new PlayerSetsDisplayEmail().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsDisplayEmail | PlainMessage<PlayerSetsDisplayEmail> | undefined, b: PlayerSetsDisplayEmail | PlainMessage<PlayerSetsDisplayEmail> | undefined): boolean {
    return proto3.util.equals(PlayerSetsDisplayEmail, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsDescription
 */
export class PlayerSetsDescription extends Message<PlayerSetsDescription> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  constructor(data?: PartialMessage<PlayerSetsDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsDescription {
    return new PlayerSetsDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsDescription {
    return new PlayerSetsDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsDescription {
    return new PlayerSetsDescription().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsDescription | PlainMessage<PlayerSetsDescription> | undefined, b: PlayerSetsDescription | PlainMessage<PlayerSetsDescription> | undefined): boolean {
    return proto3.util.equals(PlayerSetsDescription, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsProfileImageUrl
 */
export class PlayerSetsProfileImageUrl extends Message<PlayerSetsProfileImageUrl> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string profileImageUrl = 2;
   */
  profileImageUrl = "";

  constructor(data?: PartialMessage<PlayerSetsProfileImageUrl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsProfileImageUrl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "profileImageUrl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsProfileImageUrl {
    return new PlayerSetsProfileImageUrl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsProfileImageUrl {
    return new PlayerSetsProfileImageUrl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsProfileImageUrl {
    return new PlayerSetsProfileImageUrl().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsProfileImageUrl | PlainMessage<PlayerSetsProfileImageUrl> | undefined, b: PlayerSetsProfileImageUrl | PlainMessage<PlayerSetsProfileImageUrl> | undefined): boolean {
    return proto3.util.equals(PlayerSetsProfileImageUrl, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsPersonalImageUrl
 */
export class PlayerSetsPersonalImageUrl extends Message<PlayerSetsPersonalImageUrl> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string personalImageUrl = 2;
   */
  personalImageUrl = "";

  constructor(data?: PartialMessage<PlayerSetsPersonalImageUrl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsPersonalImageUrl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "personalImageUrl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsPersonalImageUrl {
    return new PlayerSetsPersonalImageUrl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsPersonalImageUrl {
    return new PlayerSetsPersonalImageUrl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsPersonalImageUrl {
    return new PlayerSetsPersonalImageUrl().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsPersonalImageUrl | PlainMessage<PlayerSetsPersonalImageUrl> | undefined, b: PlayerSetsPersonalImageUrl | PlainMessage<PlayerSetsPersonalImageUrl> | undefined): boolean {
    return proto3.util.equals(PlayerSetsPersonalImageUrl, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsIsMobile
 */
export class PlayerSetsIsMobile extends Message<PlayerSetsIsMobile> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool isMobile = 2;
   */
  isMobile = false;

  constructor(data?: PartialMessage<PlayerSetsIsMobile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsIsMobile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "isMobile", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsIsMobile {
    return new PlayerSetsIsMobile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsIsMobile {
    return new PlayerSetsIsMobile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsIsMobile {
    return new PlayerSetsIsMobile().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsIsMobile | PlainMessage<PlayerSetsIsMobile> | undefined, b: PlayerSetsIsMobile | PlainMessage<PlayerSetsIsMobile> | undefined): boolean {
    return proto3.util.equals(PlayerSetsIsMobile, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsEmojiStatus
 */
export class PlayerSetsEmojiStatus extends Message<PlayerSetsEmojiStatus> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string emojiStatus = 2;
   */
  emojiStatus = "";

  constructor(data?: PartialMessage<PlayerSetsEmojiStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsEmojiStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "emojiStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsEmojiStatus {
    return new PlayerSetsEmojiStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsEmojiStatus {
    return new PlayerSetsEmojiStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsEmojiStatus {
    return new PlayerSetsEmojiStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsEmojiStatus | PlainMessage<PlayerSetsEmojiStatus> | undefined, b: PlayerSetsEmojiStatus | PlainMessage<PlayerSetsEmojiStatus> | undefined): boolean {
    return proto3.util.equals(PlayerSetsEmojiStatus, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsAffiliation
 */
export class PlayerSetsAffiliation extends Message<PlayerSetsAffiliation> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string affiliation = 2;
   */
  affiliation = "";

  constructor(data?: PartialMessage<PlayerSetsAffiliation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsAffiliation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "affiliation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsAffiliation {
    return new PlayerSetsAffiliation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsAffiliation {
    return new PlayerSetsAffiliation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsAffiliation {
    return new PlayerSetsAffiliation().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsAffiliation | PlainMessage<PlayerSetsAffiliation> | undefined, b: PlayerSetsAffiliation | PlainMessage<PlayerSetsAffiliation> | undefined): boolean {
    return proto3.util.equals(PlayerSetsAffiliation, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerExits
 */
export class PlayerExits extends Message<PlayerExits> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  constructor(data?: PartialMessage<PlayerExits>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerExits";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerExits {
    return new PlayerExits().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerExits {
    return new PlayerExits().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerExits {
    return new PlayerExits().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerExits | PlainMessage<PlayerExits> | undefined, b: PlayerExits | PlainMessage<PlayerExits> | undefined): boolean {
    return proto3.util.equals(PlayerExits, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsCurrentlyEquippedWearables
 */
export class PlayerSetsCurrentlyEquippedWearables extends Message<PlayerSetsCurrentlyEquippedWearables> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: gathertown.DBOutfit currentlyEquippedWearables = 2;
   */
  currentlyEquippedWearables?: DBOutfit;

  constructor(data?: PartialMessage<PlayerSetsCurrentlyEquippedWearables>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsCurrentlyEquippedWearables";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "currentlyEquippedWearables", kind: "message", T: DBOutfit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsCurrentlyEquippedWearables {
    return new PlayerSetsCurrentlyEquippedWearables().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsCurrentlyEquippedWearables {
    return new PlayerSetsCurrentlyEquippedWearables().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsCurrentlyEquippedWearables {
    return new PlayerSetsCurrentlyEquippedWearables().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsCurrentlyEquippedWearables | PlainMessage<PlayerSetsCurrentlyEquippedWearables> | undefined, b: PlayerSetsCurrentlyEquippedWearables | PlainMessage<PlayerSetsCurrentlyEquippedWearables> | undefined): boolean {
    return proto3.util.equals(PlayerSetsCurrentlyEquippedWearables, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsIsSignedIn
 */
export class PlayerSetsIsSignedIn extends Message<PlayerSetsIsSignedIn> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool isSignedIn = 2;
   */
  isSignedIn = false;

  constructor(data?: PartialMessage<PlayerSetsIsSignedIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsIsSignedIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "isSignedIn", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsIsSignedIn {
    return new PlayerSetsIsSignedIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsIsSignedIn {
    return new PlayerSetsIsSignedIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsIsSignedIn {
    return new PlayerSetsIsSignedIn().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsIsSignedIn | PlainMessage<PlayerSetsIsSignedIn> | undefined, b: PlayerSetsIsSignedIn | PlainMessage<PlayerSetsIsSignedIn> | undefined): boolean {
    return proto3.util.equals(PlayerSetsIsSignedIn, a, b);
  }
}

/**
 * It's pretty wack that we're using JSON to serialize / deserialize space data here.
 * TODO: improve this by splitting this up into several events or using a better message interface
 * for this or something that doesn't require the client to JSON.parse().
 *
 * @generated from message gathertown.SpaceOverwrites
 */
export class SpaceOverwrites extends Message<SpaceOverwrites> {
  /**
   * @generated from field: string spaceData = 1;
   */
  spaceData = "";

  constructor(data?: PartialMessage<SpaceOverwrites>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceOverwrites";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spaceData", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceOverwrites {
    return new SpaceOverwrites().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceOverwrites {
    return new SpaceOverwrites().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceOverwrites {
    return new SpaceOverwrites().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceOverwrites | PlainMessage<SpaceOverwrites> | undefined, b: SpaceOverwrites | PlainMessage<SpaceOverwrites> | undefined): boolean {
    return proto3.util.equals(SpaceOverwrites, a, b);
  }
}

/**
 * @generated from message gathertown.DynamicGate
 */
export class DynamicGate extends Message<DynamicGate> {
  /**
   * @generated from field: float exposure = 1;
   */
  exposure = 0;

  /**
   * to hardcode a list of spaces that should have it on
   *
   * @generated from field: repeated string spaces = 2;
   */
  spaces: string[] = [];

  /**
   * @generated from field: optional bool refreshOnChange = 3;
   */
  refreshOnChange?: boolean;

  /**
   * @generated from field: optional uint64 minimumBuildTimestamp = 4;
   */
  minimumBuildTimestamp?: bigint;

  constructor(data?: PartialMessage<DynamicGate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.DynamicGate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exposure", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "spaces", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "refreshOnChange", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "minimumBuildTimestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamicGate {
    return new DynamicGate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamicGate {
    return new DynamicGate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamicGate {
    return new DynamicGate().fromJsonString(jsonString, options);
  }

  static equals(a: DynamicGate | PlainMessage<DynamicGate> | undefined, b: DynamicGate | PlainMessage<DynamicGate> | undefined): boolean {
    return proto3.util.equals(DynamicGate, a, b);
  }
}

/**
 * @generated from message gathertown.DynamicGates
 */
export class DynamicGates extends Message<DynamicGates> {
  /**
   * @generated from field: gathertown.DynamicGate livekitEnabled = 1;
   */
  livekitEnabled?: DynamicGate;

  /**
   * @generated from field: optional gathertown.DynamicGate livekitSelfhostEnabled = 2;
   */
  livekitSelfhostEnabled?: DynamicGate;

  /**
   * @generated from field: optional gathertown.DynamicGate agoraEnabled = 3;
   */
  agoraEnabled?: DynamicGate;

  /**
   * @generated from field: optional gathertown.DynamicGate chimeEnabled = 4;
   */
  chimeEnabled?: DynamicGate;

  /**
   * BEFORE ADDING MORE OF THESE, DO A PROPER DESIGN AND RFC PLEASE!
   *
   * @generated from field: optional gathertown.DynamicGate gatherEnabled = 5;
   */
  gatherEnabled?: DynamicGate;

  constructor(data?: PartialMessage<DynamicGates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.DynamicGates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "livekitEnabled", kind: "message", T: DynamicGate },
    { no: 2, name: "livekitSelfhostEnabled", kind: "message", T: DynamicGate, opt: true },
    { no: 3, name: "agoraEnabled", kind: "message", T: DynamicGate, opt: true },
    { no: 4, name: "chimeEnabled", kind: "message", T: DynamicGate, opt: true },
    { no: 5, name: "gatherEnabled", kind: "message", T: DynamicGate, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamicGates {
    return new DynamicGates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamicGates {
    return new DynamicGates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamicGates {
    return new DynamicGates().fromJsonString(jsonString, options);
  }

  static equals(a: DynamicGates | PlainMessage<DynamicGates> | undefined, b: DynamicGates | PlainMessage<DynamicGates> | undefined): boolean {
    return proto3.util.equals(DynamicGates, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceSetsSpaceMembers
 */
export class SpaceSetsSpaceMembers extends Message<SpaceSetsSpaceMembers> {
  /**
   * @generated from field: map<string, gathertown.SpaceMemberInfo> members = 1;
   */
  members: { [key: string]: SpaceMemberInfo } = {};

  constructor(data?: PartialMessage<SpaceSetsSpaceMembers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceSetsSpaceMembers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "members", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SpaceMemberInfo} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceSetsSpaceMembers {
    return new SpaceSetsSpaceMembers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceSetsSpaceMembers {
    return new SpaceSetsSpaceMembers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceSetsSpaceMembers {
    return new SpaceSetsSpaceMembers().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceSetsSpaceMembers | PlainMessage<SpaceSetsSpaceMembers> | undefined, b: SpaceSetsSpaceMembers | PlainMessage<SpaceSetsSpaceMembers> | undefined): boolean {
    return proto3.util.equals(SpaceSetsSpaceMembers, a, b);
  }
}

/**
 * @generated from message gathertown.WireSpaceUser
 */
export class WireSpaceUser extends Message<WireSpaceUser> {
  /**
   * role should be CoreRole, but we can't do string enums in protobuf
   *
   * @generated from field: string role = 1;
   */
  role = "";

  constructor(data?: PartialMessage<WireSpaceUser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.WireSpaceUser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WireSpaceUser {
    return new WireSpaceUser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WireSpaceUser {
    return new WireSpaceUser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WireSpaceUser {
    return new WireSpaceUser().fromJsonString(jsonString, options);
  }

  static equals(a: WireSpaceUser | PlainMessage<WireSpaceUser> | undefined, b: WireSpaceUser | PlainMessage<WireSpaceUser> | undefined): boolean {
    return proto3.util.equals(WireSpaceUser, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceSetsSpaceUsers
 */
export class SpaceSetsSpaceUsers extends Message<SpaceSetsSpaceUsers> {
  /**
   * @generated from field: map<string, gathertown.WireSpaceUser> spaceUsers = 1;
   */
  spaceUsers: { [key: string]: WireSpaceUser } = {};

  constructor(data?: PartialMessage<SpaceSetsSpaceUsers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceSetsSpaceUsers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spaceUsers", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: WireSpaceUser} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceSetsSpaceUsers {
    return new SpaceSetsSpaceUsers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceSetsSpaceUsers {
    return new SpaceSetsSpaceUsers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceSetsSpaceUsers {
    return new SpaceSetsSpaceUsers().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceSetsSpaceUsers | PlainMessage<SpaceSetsSpaceUsers> | undefined, b: SpaceSetsSpaceUsers | PlainMessage<SpaceSetsSpaceUsers> | undefined): boolean {
    return proto3.util.equals(SpaceSetsSpaceUsers, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceIsClosed
 */
export class SpaceIsClosed extends Message<SpaceIsClosed> {
  constructor(data?: PartialMessage<SpaceIsClosed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceIsClosed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceIsClosed {
    return new SpaceIsClosed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceIsClosed {
    return new SpaceIsClosed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceIsClosed {
    return new SpaceIsClosed().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceIsClosed | PlainMessage<SpaceIsClosed> | undefined, b: SpaceIsClosed | PlainMessage<SpaceIsClosed> | undefined): boolean {
    return proto3.util.equals(SpaceIsClosed, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerEntersPortal
 */
export class PlayerEntersPortal extends Message<PlayerEntersPortal> {
  /**
   * @generated from field: string targetUrl = 1;
   */
  targetUrl = "";

  /**
   * @generated from field: optional bool bypassPrompt = 2;
   */
  bypassPrompt?: boolean;

  constructor(data?: PartialMessage<PlayerEntersPortal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerEntersPortal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "targetUrl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bypassPrompt", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerEntersPortal {
    return new PlayerEntersPortal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerEntersPortal {
    return new PlayerEntersPortal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerEntersPortal {
    return new PlayerEntersPortal().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerEntersPortal | PlainMessage<PlayerEntersPortal> | undefined, b: PlayerEntersPortal | PlainMessage<PlayerEntersPortal> | undefined): boolean {
    return proto3.util.equals(PlayerEntersPortal, a, b);
  }
}

/**
 * @generated from message gathertown.CookieFound
 */
export class CookieFound extends Message<CookieFound> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  constructor(data?: PartialMessage<CookieFound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.CookieFound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CookieFound {
    return new CookieFound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CookieFound {
    return new CookieFound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CookieFound {
    return new CookieFound().fromJsonString(jsonString, options);
  }

  static equals(a: CookieFound | PlainMessage<CookieFound> | undefined, b: CookieFound | PlainMessage<CookieFound> | undefined): boolean {
    return proto3.util.equals(CookieFound, a, b);
  }
}

/**
 * Each client has a unique string id, but this is costly to send over the wire
 * so an integer value is used in its place and then converted back to the
 * corresponding string id on the client and server.
 * This event provides the mapping between a player's string id [uid]
 * and their corresponding integer id [encId].
 * (see "Player..." events above for use of encId)
 *
 * @generated from message gathertown.SpaceSetsIdMapping
 */
export class SpaceSetsIdMapping extends Message<SpaceSetsIdMapping> {
  /**
   * @generated from field: string uid = 1;
   */
  uid = "";

  /**
   * @generated from field: uint32 encId = 2;
   */
  encId = 0;

  constructor(data?: PartialMessage<SpaceSetsIdMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceSetsIdMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceSetsIdMapping {
    return new SpaceSetsIdMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceSetsIdMapping {
    return new SpaceSetsIdMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceSetsIdMapping {
    return new SpaceSetsIdMapping().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceSetsIdMapping | PlainMessage<SpaceSetsIdMapping> | undefined, b: SpaceSetsIdMapping | PlainMessage<SpaceSetsIdMapping> | undefined): boolean {
    return proto3.util.equals(SpaceSetsIdMapping, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerShootsConfetti
 */
export class PlayerShootsConfetti extends Message<PlayerShootsConfetti> {
  /**
   * the confetti shooter
   *
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  constructor(data?: PartialMessage<PlayerShootsConfetti>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerShootsConfetti";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerShootsConfetti {
    return new PlayerShootsConfetti().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerShootsConfetti {
    return new PlayerShootsConfetti().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerShootsConfetti {
    return new PlayerShootsConfetti().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerShootsConfetti | PlainMessage<PlayerShootsConfetti> | undefined, b: PlayerShootsConfetti | PlainMessage<PlayerShootsConfetti> | undefined): boolean {
    return proto3.util.equals(PlayerShootsConfetti, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsEventStatus
 */
export class PlayerSetsEventStatus extends Message<PlayerSetsEventStatus> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string eventStatus = 2;
   */
  eventStatus = "";

  constructor(data?: PartialMessage<PlayerSetsEventStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsEventStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "eventStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsEventStatus {
    return new PlayerSetsEventStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsEventStatus {
    return new PlayerSetsEventStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsEventStatus {
    return new PlayerSetsEventStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsEventStatus | PlainMessage<PlayerSetsEventStatus> | undefined, b: PlayerSetsEventStatus | PlainMessage<PlayerSetsEventStatus> | undefined): boolean {
    return proto3.util.equals(PlayerSetsEventStatus, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsInConversation
 */
export class PlayerSetsInConversation extends Message<PlayerSetsInConversation> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool inConversation = 2;
   */
  inConversation = false;

  constructor(data?: PartialMessage<PlayerSetsInConversation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsInConversation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "inConversation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsInConversation {
    return new PlayerSetsInConversation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsInConversation {
    return new PlayerSetsInConversation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsInConversation {
    return new PlayerSetsInConversation().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsInConversation | PlainMessage<PlayerSetsInConversation> | undefined, b: PlayerSetsInConversation | PlainMessage<PlayerSetsInConversation> | undefined): boolean {
    return proto3.util.equals(PlayerSetsInConversation, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsCurrentArea
 */
export class PlayerSetsCurrentArea extends Message<PlayerSetsCurrentArea> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string currentArea = 2;
   */
  currentArea = "";

  constructor(data?: PartialMessage<PlayerSetsCurrentArea>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsCurrentArea";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "currentArea", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsCurrentArea {
    return new PlayerSetsCurrentArea().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsCurrentArea {
    return new PlayerSetsCurrentArea().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsCurrentArea {
    return new PlayerSetsCurrentArea().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsCurrentArea | PlainMessage<PlayerSetsCurrentArea> | undefined, b: PlayerSetsCurrentArea | PlainMessage<PlayerSetsCurrentArea> | undefined): boolean {
    return proto3.util.equals(PlayerSetsCurrentArea, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsGoKartId
 */
export class PlayerSetsGoKartId extends Message<PlayerSetsGoKartId> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string goKartId = 2;
   */
  goKartId = "";

  constructor(data?: PartialMessage<PlayerSetsGoKartId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsGoKartId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "goKartId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsGoKartId {
    return new PlayerSetsGoKartId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsGoKartId {
    return new PlayerSetsGoKartId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsGoKartId {
    return new PlayerSetsGoKartId().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsGoKartId | PlainMessage<PlayerSetsGoKartId> | undefined, b: PlayerSetsGoKartId | PlainMessage<PlayerSetsGoKartId> | undefined): boolean {
    return proto3.util.equals(PlayerSetsGoKartId, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsVehicleId
 */
export class PlayerSetsVehicleId extends Message<PlayerSetsVehicleId> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string vehicleId = 2;
   */
  vehicleId = "";

  /**
   * @generated from field: string action = 3;
   */
  action = "";

  /**
   * @generated from field: string previousVehicleId = 4;
   */
  previousVehicleId = "";

  constructor(data?: PartialMessage<PlayerSetsVehicleId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsVehicleId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "vehicleId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "action", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "previousVehicleId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsVehicleId {
    return new PlayerSetsVehicleId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsVehicleId {
    return new PlayerSetsVehicleId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsVehicleId {
    return new PlayerSetsVehicleId().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsVehicleId | PlainMessage<PlayerSetsVehicleId> | undefined, b: PlayerSetsVehicleId | PlainMessage<PlayerSetsVehicleId> | undefined): boolean {
    return proto3.util.equals(PlayerSetsVehicleId, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsSpeedModifier
 */
export class PlayerSetsSpeedModifier extends Message<PlayerSetsSpeedModifier> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: float speedModifier = 2;
   */
  speedModifier = 0;

  constructor(data?: PartialMessage<PlayerSetsSpeedModifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsSpeedModifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "speedModifier", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsSpeedModifier {
    return new PlayerSetsSpeedModifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsSpeedModifier {
    return new PlayerSetsSpeedModifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsSpeedModifier {
    return new PlayerSetsSpeedModifier().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsSpeedModifier | PlainMessage<PlayerSetsSpeedModifier> | undefined, b: PlayerSetsSpeedModifier | PlainMessage<PlayerSetsSpeedModifier> | undefined): boolean {
    return proto3.util.equals(PlayerSetsSpeedModifier, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsIsAlone
 */
export class PlayerSetsIsAlone extends Message<PlayerSetsIsAlone> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool isAlone = 2;
   */
  isAlone = false;

  constructor(data?: PartialMessage<PlayerSetsIsAlone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsIsAlone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "isAlone", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsIsAlone {
    return new PlayerSetsIsAlone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsIsAlone {
    return new PlayerSetsIsAlone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsIsAlone {
    return new PlayerSetsIsAlone().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsIsAlone | PlainMessage<PlayerSetsIsAlone> | undefined, b: PlayerSetsIsAlone | PlainMessage<PlayerSetsIsAlone> | undefined): boolean {
    return proto3.util.equals(PlayerSetsIsAlone, a, b);
  }
}

/**
 * @generated from message gathertown.SpacePlaysSound
 */
export class SpacePlaysSound extends Message<SpacePlaysSound> {
  /**
   * @generated from field: string src = 2;
   */
  src = "";

  /**
   * @generated from field: float volume = 3;
   */
  volume = 0;

  constructor(data?: PartialMessage<SpacePlaysSound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpacePlaysSound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "src", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "volume", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpacePlaysSound {
    return new SpacePlaysSound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpacePlaysSound {
    return new SpacePlaysSound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpacePlaysSound {
    return new SpacePlaysSound().fromJsonString(jsonString, options);
  }

  static equals(a: SpacePlaysSound | PlainMessage<SpacePlaysSound> | undefined, b: SpacePlaysSound | PlainMessage<SpacePlaysSound> | undefined): boolean {
    return proto3.util.equals(SpacePlaysSound, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceStopsSound
 */
export class SpaceStopsSound extends Message<SpaceStopsSound> {
  /**
   * @generated from field: string src = 2;
   */
  src = "";

  constructor(data?: PartialMessage<SpaceStopsSound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceStopsSound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "src", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceStopsSound {
    return new SpaceStopsSound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceStopsSound {
    return new SpaceStopsSound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceStopsSound {
    return new SpaceStopsSound().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceStopsSound | PlainMessage<SpaceStopsSound> | undefined, b: SpaceStopsSound | PlainMessage<SpaceStopsSound> | undefined): boolean {
    return proto3.util.equals(SpaceStopsSound, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsFocusModeEndTime
 */
export class PlayerSetsFocusModeEndTime extends Message<PlayerSetsFocusModeEndTime> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string focusModeEndTime = 2;
   */
  focusModeEndTime = "";

  constructor(data?: PartialMessage<PlayerSetsFocusModeEndTime>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsFocusModeEndTime";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "focusModeEndTime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsFocusModeEndTime {
    return new PlayerSetsFocusModeEndTime().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsFocusModeEndTime {
    return new PlayerSetsFocusModeEndTime().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsFocusModeEndTime {
    return new PlayerSetsFocusModeEndTime().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsFocusModeEndTime | PlainMessage<PlayerSetsFocusModeEndTime> | undefined, b: PlayerSetsFocusModeEndTime | PlainMessage<PlayerSetsFocusModeEndTime> | undefined): boolean {
    return proto3.util.equals(PlayerSetsFocusModeEndTime, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerBlocks
 */
export class PlayerBlocks extends Message<PlayerBlocks> {
  /**
   * @generated from field: string blockedBy = 1;
   */
  blockedBy = "";

  /**
   * @generated from field: bool blocked = 2;
   */
  blocked = false;

  constructor(data?: PartialMessage<PlayerBlocks>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerBlocks";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blockedBy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "blocked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerBlocks {
    return new PlayerBlocks().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerBlocks {
    return new PlayerBlocks().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerBlocks {
    return new PlayerBlocks().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerBlocks | PlainMessage<PlayerBlocks> | undefined, b: PlayerBlocks | PlainMessage<PlayerBlocks> | undefined): boolean {
    return proto3.util.equals(PlayerBlocks, a, b);
  }
}

/**
 * @generated from message gathertown.CustomEvent
 */
export class CustomEvent extends Message<CustomEvent> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string payload = 2;
   */
  payload = "";

  constructor(data?: PartialMessage<CustomEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.CustomEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payload", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomEvent {
    return new CustomEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomEvent {
    return new CustomEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomEvent {
    return new CustomEvent().fromJsonString(jsonString, options);
  }

  static equals(a: CustomEvent | PlainMessage<CustomEvent> | undefined, b: CustomEvent | PlainMessage<CustomEvent> | undefined): boolean {
    return proto3.util.equals(CustomEvent, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerUpdatesFocusModeStatus
 */
export class PlayerUpdatesFocusModeStatus extends Message<PlayerUpdatesFocusModeStatus> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool isInFocusMode = 2;
   */
  isInFocusMode = false;

  constructor(data?: PartialMessage<PlayerUpdatesFocusModeStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerUpdatesFocusModeStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "isInFocusMode", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerUpdatesFocusModeStatus {
    return new PlayerUpdatesFocusModeStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerUpdatesFocusModeStatus {
    return new PlayerUpdatesFocusModeStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerUpdatesFocusModeStatus {
    return new PlayerUpdatesFocusModeStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerUpdatesFocusModeStatus | PlainMessage<PlayerUpdatesFocusModeStatus> | undefined, b: PlayerUpdatesFocusModeStatus | PlainMessage<PlayerUpdatesFocusModeStatus> | undefined): boolean {
    return proto3.util.equals(PlayerUpdatesFocusModeStatus, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsItemString
 */
export class PlayerSetsItemString extends Message<PlayerSetsItemString> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string itemString = 2;
   */
  itemString = "";

  constructor(data?: PartialMessage<PlayerSetsItemString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsItemString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "itemString", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsItemString {
    return new PlayerSetsItemString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsItemString {
    return new PlayerSetsItemString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsItemString {
    return new PlayerSetsItemString().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsItemString | PlainMessage<PlayerSetsItemString> | undefined, b: PlayerSetsItemString | PlainMessage<PlayerSetsItemString> | undefined): boolean {
    return proto3.util.equals(PlayerSetsItemString, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerTriggersObject
 */
export class PlayerTriggersObject extends Message<PlayerTriggersObject> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * mapId and key are optional because the same action is used (with empty data) to drop the thing you're carrying
   *
   * @generated from field: optional string mapId = 2;
   */
  mapId?: string;

  /**
   * @generated from field: optional string key = 3;
   */
  key?: string;

  constructor(data?: PartialMessage<PlayerTriggersObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerTriggersObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerTriggersObject {
    return new PlayerTriggersObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerTriggersObject {
    return new PlayerTriggersObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerTriggersObject {
    return new PlayerTriggersObject().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerTriggersObject | PlainMessage<PlayerTriggersObject> | undefined, b: PlayerTriggersObject | PlainMessage<PlayerTriggersObject> | undefined): boolean {
    return proto3.util.equals(PlayerTriggersObject, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerNotifies
 */
export class PlayerNotifies extends Message<PlayerNotifies> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string notification = 2;
   */
  notification = "";

  constructor(data?: PartialMessage<PlayerNotifies>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerNotifies";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "notification", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerNotifies {
    return new PlayerNotifies().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerNotifies {
    return new PlayerNotifies().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerNotifies {
    return new PlayerNotifies().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerNotifies | PlainMessage<PlayerNotifies> | undefined, b: PlayerNotifies | PlainMessage<PlayerNotifies> | undefined): boolean {
    return proto3.util.equals(PlayerNotifies, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsFollowTarget
 */
export class PlayerSetsFollowTarget extends Message<PlayerSetsFollowTarget> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string followTarget = 2;
   */
  followTarget = "";

  constructor(data?: PartialMessage<PlayerSetsFollowTarget>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsFollowTarget";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "followTarget", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsFollowTarget {
    return new PlayerSetsFollowTarget().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsFollowTarget {
    return new PlayerSetsFollowTarget().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsFollowTarget {
    return new PlayerSetsFollowTarget().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsFollowTarget | PlainMessage<PlayerSetsFollowTarget> | undefined, b: PlayerSetsFollowTarget | PlainMessage<PlayerSetsFollowTarget> | undefined): boolean {
    return proto3.util.equals(PlayerSetsFollowTarget, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerRequestsToLead
 */
export class PlayerRequestsToLead extends Message<PlayerRequestsToLead> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string snapshot = 2;
   */
  snapshot = "";

  constructor(data?: PartialMessage<PlayerRequestsToLead>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerRequestsToLead";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "snapshot", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerRequestsToLead {
    return new PlayerRequestsToLead().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerRequestsToLead {
    return new PlayerRequestsToLead().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerRequestsToLead {
    return new PlayerRequestsToLead().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerRequestsToLead | PlainMessage<PlayerRequestsToLead> | undefined, b: PlayerRequestsToLead | PlainMessage<PlayerRequestsToLead> | undefined): boolean {
    return proto3.util.equals(PlayerRequestsToLead, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsManualVideoSrc
 */
export class PlayerSetsManualVideoSrc extends Message<PlayerSetsManualVideoSrc> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string manualVideoSrc = 2;
   */
  manualVideoSrc = "";

  constructor(data?: PartialMessage<PlayerSetsManualVideoSrc>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsManualVideoSrc";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "manualVideoSrc", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsManualVideoSrc {
    return new PlayerSetsManualVideoSrc().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsManualVideoSrc {
    return new PlayerSetsManualVideoSrc().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsManualVideoSrc {
    return new PlayerSetsManualVideoSrc().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsManualVideoSrc | PlainMessage<PlayerSetsManualVideoSrc> | undefined, b: PlayerSetsManualVideoSrc | PlainMessage<PlayerSetsManualVideoSrc> | undefined): boolean {
    return proto3.util.equals(PlayerSetsManualVideoSrc, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsIsNpc
 */
export class PlayerSetsIsNpc extends Message<PlayerSetsIsNpc> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool isNpc = 2;
   */
  isNpc = false;

  constructor(data?: PartialMessage<PlayerSetsIsNpc>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsIsNpc";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "isNpc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsIsNpc {
    return new PlayerSetsIsNpc().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsIsNpc {
    return new PlayerSetsIsNpc().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsIsNpc {
    return new PlayerSetsIsNpc().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsIsNpc | PlainMessage<PlayerSetsIsNpc> | undefined, b: PlayerSetsIsNpc | PlainMessage<PlayerSetsIsNpc> | undefined): boolean {
    return proto3.util.equals(PlayerSetsIsNpc, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsSubtitle
 */
export class PlayerSetsSubtitle extends Message<PlayerSetsSubtitle> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string subtitle = 2;
   */
  subtitle = "";

  constructor(data?: PartialMessage<PlayerSetsSubtitle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsSubtitle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "subtitle", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsSubtitle {
    return new PlayerSetsSubtitle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsSubtitle {
    return new PlayerSetsSubtitle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsSubtitle {
    return new PlayerSetsSubtitle().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsSubtitle | PlainMessage<PlayerSetsSubtitle> | undefined, b: PlayerSetsSubtitle | PlainMessage<PlayerSetsSubtitle> | undefined): boolean {
    return proto3.util.equals(PlayerSetsSubtitle, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerCrafts
 */
export class PlayerCrafts extends Message<PlayerCrafts> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: map<string, uint32> inputs = 2;
   */
  inputs: { [key: string]: number } = {};

  constructor(data?: PartialMessage<PlayerCrafts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerCrafts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "inputs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 13 /* ScalarType.UINT32 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerCrafts {
    return new PlayerCrafts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerCrafts {
    return new PlayerCrafts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerCrafts {
    return new PlayerCrafts().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerCrafts | PlainMessage<PlayerCrafts> | undefined, b: PlayerCrafts | PlainMessage<PlayerCrafts> | undefined): boolean {
    return proto3.util.equals(PlayerCrafts, a, b);
  }
}

/**
 * @generated from message gathertown.MapMoveObject
 */
export class MapMoveObject extends Message<MapMoveObject> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string objectId = 2;
   */
  objectId = "";

  /**
   * @generated from field: float targetX = 3;
   */
  targetX = 0;

  /**
   * @generated from field: float targetY = 4;
   */
  targetY = 0;

  /**
   * @generated from field: optional float targetXOffset = 5;
   */
  targetXOffset?: number;

  /**
   * @generated from field: optional float targetYOffset = 6;
   */
  targetYOffset?: number;

  /**
   * Time it takes to move object (in milliseconds)
   *
   * @generated from field: float duration = 7;
   */
  duration = 0;

  /**
   * "Linear" (default) | "Cubic" | "Elastic" | "Bounce" | "Back"
   * ---
   * Linear = constant speed.
   * Cubic = slight easing.
   * Elastic = spring-like motion; object overshoots point and ping-pongs until settling on the target.
   * Bounce = similar to a bouncing object coming to rest
   * Back = object slightly overshoots point and quickly settles back onto target.
   *
   * @generated from field: optional string easing = 8;
   */
  easing?: string;

  constructor(data?: PartialMessage<MapMoveObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapMoveObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "objectId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "targetX", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 4, name: "targetY", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "targetXOffset", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 6, name: "targetYOffset", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 7, name: "duration", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 8, name: "easing", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapMoveObject {
    return new MapMoveObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapMoveObject {
    return new MapMoveObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapMoveObject {
    return new MapMoveObject().fromJsonString(jsonString, options);
  }

  static equals(a: MapMoveObject | PlainMessage<MapMoveObject> | undefined, b: MapMoveObject | PlainMessage<MapMoveObject> | undefined): boolean {
    return proto3.util.equals(MapMoveObject, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerEditsChatMessage
 */
export class PlayerEditsChatMessage extends Message<PlayerEditsChatMessage> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: optional uint32 likes = 2;
   */
  likes?: number;

  /**
   * @generated from field: optional bool replied = 3;
   */
  replied?: boolean;

  /**
   * @generated from field: optional gathertown.ChatReply reply = 4;
   */
  reply?: ChatReply;

  /**
   * @generated from field: optional bool approved = 5;
   */
  approved?: boolean;

  constructor(data?: PartialMessage<PlayerEditsChatMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerEditsChatMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "likes", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 3, name: "replied", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "reply", kind: "message", T: ChatReply, opt: true },
    { no: 5, name: "approved", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerEditsChatMessage {
    return new PlayerEditsChatMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerEditsChatMessage {
    return new PlayerEditsChatMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerEditsChatMessage {
    return new PlayerEditsChatMessage().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerEditsChatMessage | PlainMessage<PlayerEditsChatMessage> | undefined, b: PlayerEditsChatMessage | PlainMessage<PlayerEditsChatMessage> | undefined): boolean {
    return proto3.util.equals(PlayerEditsChatMessage, a, b);
  }
}

/**
 * @generated from message gathertown.FXShakeObject
 */
export class FXShakeObject extends Message<FXShakeObject> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string targetId = 2;
   */
  targetId = "";

  /**
   * @generated from field: optional float intensity = 3;
   */
  intensity?: number;

  /**
   * @generated from field: optional float durationMs = 4;
   */
  durationMs?: number;

  /**
   * @generated from field: optional uint32 mode = 5;
   */
  mode?: number;

  constructor(data?: PartialMessage<FXShakeObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.FXShakeObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "intensity", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 4, name: "durationMs", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 5, name: "mode", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FXShakeObject {
    return new FXShakeObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FXShakeObject {
    return new FXShakeObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FXShakeObject {
    return new FXShakeObject().fromJsonString(jsonString, options);
  }

  static equals(a: FXShakeObject | PlainMessage<FXShakeObject> | undefined, b: FXShakeObject | PlainMessage<FXShakeObject> | undefined): boolean {
    return proto3.util.equals(FXShakeObject, a, b);
  }
}

/**
 * @generated from message gathertown.FXShakeCamera
 */
export class FXShakeCamera extends Message<FXShakeCamera> {
  /**
   * @generated from field: optional float intensity = 1;
   */
  intensity?: number;

  /**
   * @generated from field: optional float durationMs = 2;
   */
  durationMs?: number;

  /**
   * Map on which this should be applied (empty = entire space shakes)
   *
   * @generated from field: optional string mapId = 3;
   */
  mapId?: string;

  /**
   * User ID this shake should apply to (empty = everyone in the given map or space will shake)
   * If mapID _and_ a target is provided, the map ID is disregarded and only the target user will shake.
   *
   * @generated from field: optional string targetUserId = 4;
   */
  targetUserId?: string;

  constructor(data?: PartialMessage<FXShakeCamera>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.FXShakeCamera";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intensity", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 2, name: "durationMs", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 3, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "targetUserId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FXShakeCamera {
    return new FXShakeCamera().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FXShakeCamera {
    return new FXShakeCamera().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FXShakeCamera {
    return new FXShakeCamera().fromJsonString(jsonString, options);
  }

  static equals(a: FXShakeCamera | PlainMessage<FXShakeCamera> | undefined, b: FXShakeCamera | PlainMessage<FXShakeCamera> | undefined): boolean {
    return proto3.util.equals(FXShakeCamera, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerHighFives
 */
export class PlayerHighFives extends Message<PlayerHighFives> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: uint32 encIdTarget = 2;
   */
  encIdTarget = 0;

  /**
   * @generated from field: optional string emote = 3;
   */
  emote?: string;

  constructor(data?: PartialMessage<PlayerHighFives>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerHighFives";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "encIdTarget", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "emote", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerHighFives {
    return new PlayerHighFives().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerHighFives {
    return new PlayerHighFives().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerHighFives {
    return new PlayerHighFives().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerHighFives | PlainMessage<PlayerHighFives> | undefined, b: PlayerHighFives | PlainMessage<PlayerHighFives> | undefined): boolean {
    return proto3.util.equals(PlayerHighFives, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSendsCommand
 */
export class PlayerSendsCommand extends Message<PlayerSendsCommand> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string command = 2;
   */
  command = "";

  constructor(data?: PartialMessage<PlayerSendsCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSendsCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSendsCommand {
    return new PlayerSendsCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSendsCommand {
    return new PlayerSendsCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSendsCommand {
    return new PlayerSendsCommand().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSendsCommand | PlainMessage<PlayerSendsCommand> | undefined, b: PlayerSendsCommand | PlainMessage<PlayerSendsCommand> | undefined): boolean {
    return proto3.util.equals(PlayerSendsCommand, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceRegistersCommand
 */
export class SpaceRegistersCommand extends Message<SpaceRegistersCommand> {
  /**
   * @generated from field: string command = 2;
   */
  command = "";

  constructor(data?: PartialMessage<SpaceRegistersCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceRegistersCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceRegistersCommand {
    return new SpaceRegistersCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceRegistersCommand {
    return new SpaceRegistersCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceRegistersCommand {
    return new SpaceRegistersCommand().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceRegistersCommand | PlainMessage<SpaceRegistersCommand> | undefined, b: SpaceRegistersCommand | PlainMessage<SpaceRegistersCommand> | undefined): boolean {
    return proto3.util.equals(SpaceRegistersCommand, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerUpdatesInventory
 */
export class PlayerUpdatesInventory extends Message<PlayerUpdatesInventory> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * maps item ids to item data
   *
   * @generated from field: map<string, gathertown.InventoryItem> items = 2;
   */
  items: { [key: string]: InventoryItem } = {};

  /**
   * maps item ids to order string (e.g. "1,2" or "left-hand")
   *
   * @generated from field: map<string, string> order = 3;
   */
  order: { [key: string]: string } = {};

  constructor(data?: PartialMessage<PlayerUpdatesInventory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerUpdatesInventory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "items", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: InventoryItem} },
    { no: 3, name: "order", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerUpdatesInventory {
    return new PlayerUpdatesInventory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerUpdatesInventory {
    return new PlayerUpdatesInventory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerUpdatesInventory {
    return new PlayerUpdatesInventory().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerUpdatesInventory | PlainMessage<PlayerUpdatesInventory> | undefined, b: PlayerUpdatesInventory | PlainMessage<PlayerUpdatesInventory> | undefined): boolean {
    return proto3.util.equals(PlayerUpdatesInventory, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceUpdatesItems
 */
export class SpaceUpdatesItems extends Message<SpaceUpdatesItems> {
  /**
   * maps item id to the full info about that Item
   *
   * @generated from field: map<string, gathertown.SpaceItem> items = 1;
   */
  items: { [key: string]: SpaceItem } = {};

  constructor(data?: PartialMessage<SpaceUpdatesItems>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceUpdatesItems";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SpaceItem} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceUpdatesItems {
    return new SpaceUpdatesItems().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceUpdatesItems {
    return new SpaceUpdatesItems().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceUpdatesItems {
    return new SpaceUpdatesItems().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceUpdatesItems | PlainMessage<SpaceUpdatesItems> | undefined, b: SpaceUpdatesItems | PlainMessage<SpaceUpdatesItems> | undefined): boolean {
    return proto3.util.equals(SpaceUpdatesItems, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerTriggersInventoryItem
 */
export class PlayerTriggersInventoryItem extends Message<PlayerTriggersInventoryItem> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string itemId = 2;
   */
  itemId = "";

  /**
   * @generated from field: string abilityId = 3;
   */
  abilityId = "";

  constructor(data?: PartialMessage<PlayerTriggersInventoryItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerTriggersInventoryItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "itemId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "abilityId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerTriggersInventoryItem {
    return new PlayerTriggersInventoryItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerTriggersInventoryItem {
    return new PlayerTriggersInventoryItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerTriggersInventoryItem {
    return new PlayerTriggersInventoryItem().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerTriggersInventoryItem | PlainMessage<PlayerTriggersInventoryItem> | undefined, b: PlayerTriggersInventoryItem | PlainMessage<PlayerTriggersInventoryItem> | undefined): boolean {
    return proto3.util.equals(PlayerTriggersInventoryItem, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsAllowScreenPointer
 */
export class PlayerSetsAllowScreenPointer extends Message<PlayerSetsAllowScreenPointer> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool allowScreenPointer = 2;
   */
  allowScreenPointer = false;

  constructor(data?: PartialMessage<PlayerSetsAllowScreenPointer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsAllowScreenPointer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "allowScreenPointer", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsAllowScreenPointer {
    return new PlayerSetsAllowScreenPointer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsAllowScreenPointer {
    return new PlayerSetsAllowScreenPointer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsAllowScreenPointer {
    return new PlayerSetsAllowScreenPointer().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsAllowScreenPointer | PlainMessage<PlayerSetsAllowScreenPointer> | undefined, b: PlayerSetsAllowScreenPointer | PlainMessage<PlayerSetsAllowScreenPointer> | undefined): boolean {
    return proto3.util.equals(PlayerSetsAllowScreenPointer, a, b);
  }
}

/**
 * @generated from message gathertown.PrecomputedEnterLocation
 */
export class PrecomputedEnterLocation extends Message<PrecomputedEnterLocation> {
  /**
   * @generated from field: gathertown.MapLocation enterLocation = 1;
   */
  enterLocation?: MapLocation;

  constructor(data?: PartialMessage<PrecomputedEnterLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PrecomputedEnterLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enterLocation", kind: "message", T: MapLocation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrecomputedEnterLocation {
    return new PrecomputedEnterLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrecomputedEnterLocation {
    return new PrecomputedEnterLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrecomputedEnterLocation {
    return new PrecomputedEnterLocation().fromJsonString(jsonString, options);
  }

  static equals(a: PrecomputedEnterLocation | PlainMessage<PrecomputedEnterLocation> | undefined, b: PrecomputedEnterLocation | PlainMessage<PrecomputedEnterLocation> | undefined): boolean {
    return proto3.util.equals(PrecomputedEnterLocation, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsDeskInfo
 */
export class PlayerSetsDeskInfo extends Message<PlayerSetsDeskInfo> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: gathertown.DeskInfoV2 deskInfo = 2;
   */
  deskInfo?: DeskInfoV2;

  constructor(data?: PartialMessage<PlayerSetsDeskInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsDeskInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "deskInfo", kind: "message", T: DeskInfoV2 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsDeskInfo {
    return new PlayerSetsDeskInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsDeskInfo {
    return new PlayerSetsDeskInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsDeskInfo {
    return new PlayerSetsDeskInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsDeskInfo | PlainMessage<PlayerSetsDeskInfo> | undefined, b: PlayerSetsDeskInfo | PlainMessage<PlayerSetsDeskInfo> | undefined): boolean {
    return proto3.util.equals(PlayerSetsDeskInfo, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceSetsCapacity
 */
export class SpaceSetsCapacity extends Message<SpaceSetsCapacity> {
  /**
   * @generated from field: uint32 capacity = 1;
   */
  capacity = 0;

  constructor(data?: PartialMessage<SpaceSetsCapacity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceSetsCapacity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "capacity", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceSetsCapacity {
    return new SpaceSetsCapacity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceSetsCapacity {
    return new SpaceSetsCapacity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceSetsCapacity {
    return new SpaceSetsCapacity().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceSetsCapacity | PlainMessage<SpaceSetsCapacity> | undefined, b: SpaceSetsCapacity | PlainMessage<SpaceSetsCapacity> | undefined): boolean {
    return proto3.util.equals(SpaceSetsCapacity, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceOverCapacityDeniesUser
 */
export class SpaceOverCapacityDeniesUser extends Message<SpaceOverCapacityDeniesUser> {
  /**
   * @generated from field: string userId = 1;
   */
  userId = "";

  constructor(data?: PartialMessage<SpaceOverCapacityDeniesUser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceOverCapacityDeniesUser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "userId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceOverCapacityDeniesUser {
    return new SpaceOverCapacityDeniesUser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceOverCapacityDeniesUser {
    return new SpaceOverCapacityDeniesUser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceOverCapacityDeniesUser {
    return new SpaceOverCapacityDeniesUser().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceOverCapacityDeniesUser | PlainMessage<SpaceOverCapacityDeniesUser> | undefined, b: SpaceOverCapacityDeniesUser | PlainMessage<SpaceOverCapacityDeniesUser> | undefined): boolean {
    return proto3.util.equals(SpaceOverCapacityDeniesUser, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerSetsAway
 */
export class PlayerSetsAway extends Message<PlayerSetsAway> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: bool away = 2;
   */
  away = false;

  constructor(data?: PartialMessage<PlayerSetsAway>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerSetsAway";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "away", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerSetsAway {
    return new PlayerSetsAway().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerSetsAway {
    return new PlayerSetsAway().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerSetsAway {
    return new PlayerSetsAway().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerSetsAway | PlainMessage<PlayerSetsAway> | undefined, b: PlayerSetsAway | PlainMessage<PlayerSetsAway> | undefined): boolean {
    return proto3.util.equals(PlayerSetsAway, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerStartsRecording
 */
export class PlayerStartsRecording extends Message<PlayerStartsRecording> {
  /**
   * @generated from field: uint32 encId = 1;
   */
  encId = 0;

  /**
   * @generated from field: string nookId = 2;
   */
  nookId = "";

  /**
   * @generated from field: optional bool initializing = 3;
   */
  initializing?: boolean;

  constructor(data?: PartialMessage<PlayerStartsRecording>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerStartsRecording";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "nookId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initializing", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerStartsRecording {
    return new PlayerStartsRecording().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerStartsRecording {
    return new PlayerStartsRecording().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerStartsRecording {
    return new PlayerStartsRecording().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerStartsRecording | PlainMessage<PlayerStartsRecording> | undefined, b: PlayerStartsRecording | PlainMessage<PlayerStartsRecording> | undefined): boolean {
    return proto3.util.equals(PlayerStartsRecording, a, b);
  }
}

/**
 * @generated from message gathertown.AccessRequest
 */
export class AccessRequest extends Message<AccessRequest> {
  /**
   * @generated from field: string guestId = 1;
   */
  guestId = "";

  /**
   * @generated from field: string memberId = 2;
   */
  memberId = "";

  /**
   * @generated from field: uint64 requestedAtUnixTime = 3;
   */
  requestedAtUnixTime = protoInt64.zero;

  /**
   * @generated from field: string guestName = 4;
   */
  guestName = "";

  /**
   * @generated from field: optional gathertown.DBOutfit guestCurrentlyEquippedWearables = 6;
   */
  guestCurrentlyEquippedWearables?: DBOutfit;

  constructor(data?: PartialMessage<AccessRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.AccessRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "guestId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "memberId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "requestedAtUnixTime", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "guestName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "guestCurrentlyEquippedWearables", kind: "message", T: DBOutfit, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequest {
    return new AccessRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequest {
    return new AccessRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequest {
    return new AccessRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequest | PlainMessage<AccessRequest> | undefined, b: AccessRequest | PlainMessage<AccessRequest> | undefined): boolean {
    return proto3.util.equals(AccessRequest, a, b);
  }
}

/**
 * @generated from message gathertown.AccessRequestsUpdated
 */
export class AccessRequestsUpdated extends Message<AccessRequestsUpdated> {
  /**
   * @generated from field: repeated gathertown.AccessRequest requests = 1;
   */
  requests: AccessRequest[] = [];

  constructor(data?: PartialMessage<AccessRequestsUpdated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.AccessRequestsUpdated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: AccessRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestsUpdated {
    return new AccessRequestsUpdated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestsUpdated {
    return new AccessRequestsUpdated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestsUpdated {
    return new AccessRequestsUpdated().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestsUpdated | PlainMessage<AccessRequestsUpdated> | undefined, b: AccessRequestsUpdated | PlainMessage<AccessRequestsUpdated> | undefined): boolean {
    return proto3.util.equals(AccessRequestsUpdated, a, b);
  }
}

/**
 * @generated from message gathertown.AccessRequestRespondedTo
 */
export class AccessRequestRespondedTo extends Message<AccessRequestRespondedTo> {
  /**
   * @generated from field: string targetId = 1;
   */
  targetId = "";

  /**
   * @generated from field: bool accepted = 2;
   */
  accepted = false;

  /**
   * @generated from field: gathertown.MapLocation location = 3;
   */
  location?: MapLocation;

  constructor(data?: PartialMessage<AccessRequestRespondedTo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.AccessRequestRespondedTo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "accepted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "location", kind: "message", T: MapLocation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessRequestRespondedTo {
    return new AccessRequestRespondedTo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessRequestRespondedTo {
    return new AccessRequestRespondedTo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessRequestRespondedTo {
    return new AccessRequestRespondedTo().fromJsonString(jsonString, options);
  }

  static equals(a: AccessRequestRespondedTo | PlainMessage<AccessRequestRespondedTo> | undefined, b: AccessRequestRespondedTo | PlainMessage<AccessRequestRespondedTo> | undefined): boolean {
    return proto3.util.equals(AccessRequestRespondedTo, a, b);
  }
}

/**
 * @generated from message gathertown.PlayerGuestPassStatus
 */
export class PlayerGuestPassStatus extends Message<PlayerGuestPassStatus> {
  /**
   * @generated from field: string userId = 1;
   */
  userId = "";

  /**
   * @generated from field: string guestPassStatus = 2;
   */
  guestPassStatus = "";

  constructor(data?: PartialMessage<PlayerGuestPassStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlayerGuestPassStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "userId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "guestPassStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlayerGuestPassStatus {
    return new PlayerGuestPassStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlayerGuestPassStatus {
    return new PlayerGuestPassStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlayerGuestPassStatus {
    return new PlayerGuestPassStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PlayerGuestPassStatus | PlainMessage<PlayerGuestPassStatus> | undefined, b: PlayerGuestPassStatus | PlainMessage<PlayerGuestPassStatus> | undefined): boolean {
    return proto3.util.equals(PlayerGuestPassStatus, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceSetsGuestPassStatuses
 */
export class SpaceSetsGuestPassStatuses extends Message<SpaceSetsGuestPassStatuses> {
  /**
   * @generated from field: repeated gathertown.PlayerGuestPassStatus playerGuestPassStatuses = 1;
   */
  playerGuestPassStatuses: PlayerGuestPassStatus[] = [];

  constructor(data?: PartialMessage<SpaceSetsGuestPassStatuses>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceSetsGuestPassStatuses";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "playerGuestPassStatuses", kind: "message", T: PlayerGuestPassStatus, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceSetsGuestPassStatuses {
    return new SpaceSetsGuestPassStatuses().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceSetsGuestPassStatuses {
    return new SpaceSetsGuestPassStatuses().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceSetsGuestPassStatuses {
    return new SpaceSetsGuestPassStatuses().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceSetsGuestPassStatuses | PlainMessage<SpaceSetsGuestPassStatuses> | undefined, b: SpaceSetsGuestPassStatuses | PlainMessage<SpaceSetsGuestPassStatuses> | undefined): boolean {
    return proto3.util.equals(SpaceSetsGuestPassStatuses, a, b);
  }
}

/**
 * @generated from message gathertown.SetDeskFromNextAvailableDesk
 */
export class SetDeskFromNextAvailableDesk extends Message<SetDeskFromNextAvailableDesk> {
  /**
   * @generated from field: optional string targetId = 1;
   */
  targetId?: string;

  /**
   * @generated from field: optional gathertown.MapAndDesk preferredDesk = 2;
   */
  preferredDesk?: MapAndDesk;

  /**
   * @generated from field: repeated gathertown.MapAndDesk desksToIgnore = 3;
   */
  desksToIgnore: MapAndDesk[] = [];

  constructor(data?: PartialMessage<SetDeskFromNextAvailableDesk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetDeskFromNextAvailableDesk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "preferredDesk", kind: "message", T: MapAndDesk, opt: true },
    { no: 3, name: "desksToIgnore", kind: "message", T: MapAndDesk, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetDeskFromNextAvailableDesk {
    return new SetDeskFromNextAvailableDesk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetDeskFromNextAvailableDesk {
    return new SetDeskFromNextAvailableDesk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetDeskFromNextAvailableDesk {
    return new SetDeskFromNextAvailableDesk().fromJsonString(jsonString, options);
  }

  static equals(a: SetDeskFromNextAvailableDesk | PlainMessage<SetDeskFromNextAvailableDesk> | undefined, b: SetDeskFromNextAvailableDesk | PlainMessage<SetDeskFromNextAvailableDesk> | undefined): boolean {
    return proto3.util.equals(SetDeskFromNextAvailableDesk, a, b);
  }
}

/**
 * @generated from message gathertown.SpaceRolePermissionOverrideUpdated
 */
export class SpaceRolePermissionOverrideUpdated extends Message<SpaceRolePermissionOverrideUpdated> {
  /**
   * @generated from field: string role = 1;
   */
  role = "";

  /**
   * @generated from field: string permission = 2;
   */
  permission = "";

  /**
   * @generated from field: bool enabled = 3;
   */
  enabled = false;

  constructor(data?: PartialMessage<SpaceRolePermissionOverrideUpdated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpaceRolePermissionOverrideUpdated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpaceRolePermissionOverrideUpdated {
    return new SpaceRolePermissionOverrideUpdated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpaceRolePermissionOverrideUpdated {
    return new SpaceRolePermissionOverrideUpdated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpaceRolePermissionOverrideUpdated {
    return new SpaceRolePermissionOverrideUpdated().fromJsonString(jsonString, options);
  }

  static equals(a: SpaceRolePermissionOverrideUpdated | PlainMessage<SpaceRolePermissionOverrideUpdated> | undefined, b: SpaceRolePermissionOverrideUpdated | PlainMessage<SpaceRolePermissionOverrideUpdated> | undefined): boolean {
    return proto3.util.equals(SpaceRolePermissionOverrideUpdated, a, b);
  }
}

/**
 * @generated from message gathertown.ChimeSetsUserInfo
 */
export class ChimeSetsUserInfo extends Message<ChimeSetsUserInfo> {
  /**
   * @generated from field: string resource = 1;
   */
  resource = "";

  constructor(data?: PartialMessage<ChimeSetsUserInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ChimeSetsUserInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChimeSetsUserInfo {
    return new ChimeSetsUserInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChimeSetsUserInfo {
    return new ChimeSetsUserInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChimeSetsUserInfo {
    return new ChimeSetsUserInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ChimeSetsUserInfo | PlainMessage<ChimeSetsUserInfo> | undefined, b: ChimeSetsUserInfo | PlainMessage<ChimeSetsUserInfo> | undefined): boolean {
    return proto3.util.equals(ChimeSetsUserInfo, a, b);
  }
}

/**
 * @generated from message gathertown.ClientServerBatch
 */
export class ClientServerBatch extends Message<ClientServerBatch> {
  /**
   * don't add more stuff here
   *
   * @generated from field: repeated gathertown.ClientServerAction actions = 1;
   */
  actions: ClientServerAction[] = [];

  constructor(data?: PartialMessage<ClientServerBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ClientServerBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "actions", kind: "message", T: ClientServerAction, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientServerBatch {
    return new ClientServerBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientServerBatch {
    return new ClientServerBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientServerBatch {
    return new ClientServerBatch().fromJsonString(jsonString, options);
  }

  static equals(a: ClientServerBatch | PlainMessage<ClientServerBatch> | undefined, b: ClientServerBatch | PlainMessage<ClientServerBatch> | undefined): boolean {
    return proto3.util.equals(ClientServerBatch, a, b);
  }
}

/**
 * @generated from message gathertown.ClientServerAction
 */
export class ClientServerAction extends Message<ClientServerAction> {
  /**
   * future: optional txnID field
   *
   * @generated from field: optional uint32 txnId = 100;
   */
  txnId?: number;

  /**
   * @generated from oneof gathertown.ClientServerAction.action
   */
  action: {
    /**
     * @generated from field: gathertown.ClientHeartbeat clientHeartbeat = 1;
     */
    value: ClientHeartbeat;
    case: "clientHeartbeat";
  } | {
    /**
     * @generated from field: gathertown.ClientBackupHeartbeat clientBackupHeartbeat = 2;
     */
    value: ClientBackupHeartbeat;
    case: "clientBackupHeartbeat";
  } | {
    /**
     * @generated from field: gathertown.UpdateSubscriptions updateSubscriptions = 3;
     */
    value: UpdateSubscriptions;
    case: "updateSubscriptions";
  } | {
    /**
     * @generated from field: gathertown.Move move = 5;
     */
    value: Move;
    case: "move";
  } | {
    /**
     * @generated from field: gathertown.SetAffiliation setAffiliation = 7;
     */
    value: SetAffiliation;
    case: "setAffiliation";
  } | {
    /**
     * @generated from field: gathertown.SetStatus setStatus = 8;
     */
    value: SetStatus;
    case: "setStatus";
  } | {
    /**
     * @generated from field: gathertown.Spotlight spotlight = 9;
     */
    value: Spotlight;
    case: "spotlight";
  } | {
    /**
     * @generated from field: gathertown.Ring ring = 10;
     */
    value: Ring;
    case: "ring";
  } | {
    /**
     * @generated from field: gathertown.Ban ban = 12;
     */
    value: Ban;
    case: "ban";
  } | {
    /**
     * @generated from field: gathertown.Kick kick = 13;
     */
    value: Kick;
    case: "kick";
  } | {
    /**
     * deprecating (NGN-705)
     *
     * @generated from field: gathertown.SetImpassable setImpassable = 14;
     */
    value: SetImpassable;
    case: "setImpassable";
  } | {
    /**
     * @generated from field: gathertown.Chat chat = 15;
     */
    value: Chat;
    case: "chat";
  } | {
    /**
     * @generated from field: gathertown.Deprecated interact = 18;
     */
    value: Deprecated;
    case: "interact";
  } | {
    /**
     * @generated from field: gathertown.EnterWhisper enterWhisper = 19;
     */
    value: EnterWhisper;
    case: "enterWhisper";
  } | {
    /**
     * @generated from field: gathertown.LeaveWhisper leaveWhisper = 20;
     */
    value: LeaveWhisper;
    case: "leaveWhisper";
  } | {
    /**
     * @generated from field: gathertown.SetEmojiStatus setEmojiStatus = 21;
     */
    value: SetEmojiStatus;
    case: "setEmojiStatus";
  } | {
    /**
     * @generated from field: gathertown.ActivelySpeaking activelySpeaking = 22;
     */
    value: ActivelySpeaking;
    case: "activelySpeaking";
  } | {
    /**
     * @generated from field: gathertown.SetName setName = 24;
     */
    value: SetName;
    case: "setName";
  } | {
    /**
     * @generated from field: gathertown.SetTextStatus setTextStatus = 25;
     */
    value: SetTextStatus;
    case: "setTextStatus";
  } | {
    /**
     * @generated from field: gathertown.Teleport teleport = 26;
     */
    value: Teleport;
    case: "teleport";
  } | {
    /**
     * @generated from field: gathertown.Exit exit = 27;
     */
    value: Exit;
    case: "exit";
  } | {
    /**
     * @generated from field: gathertown.Enter enter = 28;
     */
    value: Enter;
    case: "enter";
  } | {
    /**
     * @generated from field: gathertown.Deprecated setWorkCondition = 29;
     */
    value: Deprecated;
    case: "setWorkCondition";
  } | {
    /**
     * @generated from field: gathertown.Respawn respawn = 30;
     */
    value: Respawn;
    case: "respawn";
  } | {
    /**
     * @generated from field: gathertown.Spawn spawn = 31;
     */
    value: Spawn;
    case: "spawn";
  } | {
    /**
     * @generated from field: gathertown.Ghost ghost = 32;
     */
    value: Ghost;
    case: "ghost";
  } | {
    /**
     * @generated from field: gathertown.Init init = 33;
     */
    value: Init;
    case: "init";
  } | {
    /**
     * @generated from field: gathertown.Deprecated setOutfitString = 34;
     */
    value: Deprecated;
    case: "setOutfitString";
  } | {
    /**
     * @generated from field: gathertown.ShootConfetti shootConfetti = 36;
     */
    value: ShootConfetti;
    case: "shootConfetti";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.SetEventStatus setEventStatus = 37;
     */
    value: SetEventStatus;
    case: "setEventStatus";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.SetInConversation setInConversation = 38;
     */
    value: SetInConversation;
    case: "setInConversation";
  } | {
    /**
     * @generated from field: gathertown.Deprecated setCurrentDesk = 39;
     */
    value: Deprecated;
    case: "setCurrentDesk";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.SetCurrentArea setCurrentArea = 40;
     */
    value: SetCurrentArea;
    case: "setCurrentArea";
  } | {
    /**
     * @generated from field: gathertown.SetImagePointer setImagePointer = 41;
     */
    value: SetImagePointer;
    case: "setImagePointer";
  } | {
    /**
     * @generated from field: gathertown.Deprecated setGoKartId = 42;
     */
    value: Deprecated;
    case: "setGoKartId";
  } | {
    /**
     * @generated from field: gathertown.MapSetDimensions mapSetDimensions = 43;
     */
    value: MapSetDimensions;
    case: "mapSetDimensions";
  } | {
    /**
     * @generated from field: gathertown.MapSetCollisions mapSetCollisions = 44;
     */
    value: MapSetCollisions;
    case: "mapSetCollisions";
  } | {
    /**
     * @generated from field: gathertown.MapSetBackgroundImagePath mapSetBackgroundImagePath = 45;
     */
    value: MapSetBackgroundImagePath;
    case: "mapSetBackgroundImagePath";
  } | {
    /**
     * @generated from field: gathertown.MapSetForegroundImagePath mapSetForegroundImagePath = 46;
     */
    value: MapSetForegroundImagePath;
    case: "mapSetForegroundImagePath";
  } | {
    /**
     * deprecated (NGN-106)
     *
     * @generated from field: gathertown.Deprecated mapSetSprites = 47;
     */
    value: Deprecated;
    case: "mapSetSprites";
  } | {
    /**
     * @generated from field: gathertown.MapSetSpawns mapSetSpawns = 48;
     */
    value: MapSetSpawns;
    case: "mapSetSpawns";
  } | {
    /**
     * @generated from field: gathertown.Deprecated mapSetSpaces = 49;
     */
    value: Deprecated;
    case: "mapSetSpaces";
  } | {
    /**
     * @generated from field: gathertown.MapSetPortals mapSetPortals = 50;
     */
    value: MapSetPortals;
    case: "mapSetPortals";
  } | {
    /**
     * @generated from field: gathertown.MapSetAnnouncer mapSetAnnouncer = 51;
     */
    value: MapSetAnnouncer;
    case: "mapSetAnnouncer";
  } | {
    /**
     * deprecating (use type 0 objects) (NGN-123)
     *
     * @generated from field: gathertown.MapSetAssets mapSetAssets = 54;
     */
    value: MapSetAssets;
    case: "mapSetAssets";
  } | {
    /**
     * deprecated in favor of mapUpdateObjects
     *
     * @generated from field: gathertown.Deprecated mapSetObjects = 55;
     */
    value: Deprecated;
    case: "mapSetObjects";
  } | {
    /**
     * @generated from field: gathertown.MapSetName mapSetName = 56;
     */
    value: MapSetName;
    case: "mapSetName";
  } | {
    /**
     * @generated from field: gathertown.MapSetMuteOnEntry mapSetMuteOnEntry = 58;
     */
    value: MapSetMuteOnEntry;
    case: "mapSetMuteOnEntry";
  } | {
    /**
     * @generated from field: gathertown.MapSetUseDrawnBG mapSetUseDrawnBG = 59;
     */
    value: MapSetUseDrawnBG;
    case: "mapSetUseDrawnBG";
  } | {
    /**
     * @generated from field: gathertown.MapSetWalls mapSetWalls = 60;
     */
    value: MapSetWalls;
    case: "mapSetWalls";
  } | {
    /**
     * @generated from field: gathertown.MapSetFloors mapSetFloors = 61;
     */
    value: MapSetFloors;
    case: "mapSetFloors";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.MapSetAreas mapSetAreas = 62;
     */
    value: MapSetAreas;
    case: "mapSetAreas";
  } | {
    /**
     * @generated from field: gathertown.MapAddObject mapAddObject = 63;
     */
    value: MapAddObject;
    case: "mapAddObject";
  } | {
    /**
     * deprecated in favor of mapDeleteObjectByKey
     *
     * @generated from field: gathertown.Deprecated mapDeleteObject = 64;
     */
    value: Deprecated;
    case: "mapDeleteObject";
  } | {
    /**
     * deprecating (NGN-104)
     *
     * @generated from field: gathertown.MapSetSpawn mapSetSpawn = 65;
     */
    value: MapSetSpawn;
    case: "mapSetSpawn";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.SetIsAlone setIsAlone = 66;
     */
    value: SetIsAlone;
    case: "setIsAlone";
  } | {
    /**
     * @generated from field: gathertown.MapSetMiniMapImagePath mapSetMiniMapImagePath = 67;
     */
    value: MapSetMiniMapImagePath;
    case: "mapSetMiniMapImagePath";
  } | {
    /**
     * @generated from field: gathertown.MapSetEnabledChats mapSetEnabledChats = 68;
     */
    value: MapSetEnabledChats;
    case: "mapSetEnabledChats";
  } | {
    /**
     * @generated from field: gathertown.MapSetDescription mapSetDescription = 69;
     */
    value: MapSetDescription;
    case: "mapSetDescription";
  } | {
    /**
     * @generated from field: gathertown.MapSetDecoration mapSetDecoration = 70;
     */
    value: MapSetDecoration;
    case: "mapSetDecoration";
  } | {
    /**
     * @generated from field: gathertown.MapSetTutorialTasks mapSetTutorialTasks = 71;
     */
    value: MapSetTutorialTasks;
    case: "mapSetTutorialTasks";
  } | {
    /**
     * @generated from field: gathertown.PlaySound playSound = 72;
     */
    value: PlaySound;
    case: "playSound";
  } | {
    /**
     * @generated from field: gathertown.MapSetScript mapSetScript = 73;
     */
    value: MapSetScript;
    case: "mapSetScript";
  } | {
    /**
     * @generated from field: gathertown.SetIsMobile setIsMobile = 75;
     */
    value: SetIsMobile;
    case: "setIsMobile";
  } | {
    /**
     * @generated from field: gathertown.SetScreenPointer setScreenPointer = 76;
     */
    value: SetScreenPointer;
    case: "setScreenPointer";
  } | {
    /**
     * @generated from field: gathertown.SetEmoteV2 setEmoteV2 = 77;
     */
    value: SetEmoteV2;
    case: "setEmoteV2";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.SetFocusModeEndTime setFocusModeEndTime = 78;
     */
    value: SetFocusModeEndTime;
    case: "setFocusModeEndTime";
  } | {
    /**
     * @generated from field: gathertown.MapDeleteObjectById mapDeleteObjectById = 79;
     */
    value: MapDeleteObjectById;
    case: "mapDeleteObjectById";
  } | {
    /**
     * @generated from field: gathertown.CustomAction customAction = 80;
     */
    value: CustomAction;
    case: "customAction";
  } | {
    /**
     * @generated from field: gathertown.Block block = 82;
     */
    value: Block;
    case: "block";
  } | {
    /**
     * @generated from field: gathertown.SetItemString setItemString = 83;
     */
    value: SetItemString;
    case: "setItemString";
  } | {
    /**
     * @generated from field: gathertown.Deprecated triggerItem = 84;
     */
    value: Deprecated;
    case: "triggerItem";
  } | {
    /**
     * @generated from field: gathertown.Notify notify = 85;
     */
    value: Notify;
    case: "notify";
  } | {
    /**
     * @generated from field: gathertown.SetFollowTarget setFollowTarget = 86;
     */
    value: SetFollowTarget;
    case: "setFollowTarget";
  } | {
    /**
     * @generated from field: gathertown.RequestToLead requestToLead = 87;
     */
    value: RequestToLead;
    case: "requestToLead";
  } | {
    /**
     * @generated from field: gathertown.EnterPortal enterPortal = 88;
     */
    value: EnterPortal;
    case: "enterPortal";
  } | {
    /**
     * @generated from field: gathertown.SetManualVideoSrc setManualVideoSrc = 89;
     */
    value: SetManualVideoSrc;
    case: "setManualVideoSrc";
  } | {
    /**
     * @generated from field: gathertown.SetSubtitle setSubtitle = 90;
     */
    value: SetSubtitle;
    case: "setSubtitle";
  } | {
    /**
     * @generated from field: gathertown.Deprecated playerUpdatesSession = 91;
     */
    value: Deprecated;
    case: "playerUpdatesSession";
  } | {
    /**
     * @generated from field: gathertown.MapMoveObject mapMoveObject = 92;
     */
    value: MapMoveObject;
    case: "mapMoveObject";
  } | {
    /**
     * @generated from field: gathertown.ChatMessageUpdated chatMessageUpdated = 93;
     */
    value: ChatMessageUpdated;
    case: "chatMessageUpdated";
  } | {
    /**
     * @generated from field: gathertown.FXShakeObject fxShakeObject = 94;
     */
    value: FXShakeObject;
    case: "fxShakeObject";
  } | {
    /**
     * @generated from field: gathertown.FXShakeCamera fxShakeCamera = 95;
     */
    value: FXShakeCamera;
    case: "fxShakeCamera";
  } | {
    /**
     * @generated from field: gathertown.RegisterCommand registerCommand = 96;
     */
    value: RegisterCommand;
    case: "registerCommand";
  } | {
    /**
     * @generated from field: gathertown.SendCommand sendCommand = 97;
     */
    value: SendCommand;
    case: "sendCommand";
  } | {
    /**
     * @generated from field: gathertown.SpeakerUpdatesSession speakerUpdatesSession = 98;
     */
    value: SpeakerUpdatesSession;
    case: "speakerUpdatesSession";
  } | {
    /**
     * @generated from field: gathertown.AddInventoryItem addInventoryItem = 101;
     */
    value: AddInventoryItem;
    case: "addInventoryItem";
  } | {
    /**
     * @generated from field: gathertown.RemoveInventoryItem removeInventoryItem = 102;
     */
    value: RemoveInventoryItem;
    case: "removeInventoryItem";
  } | {
    /**
     * @generated from field: gathertown.SetVehicleId setVehicleId = 103;
     */
    value: SetVehicleId;
    case: "setVehicleId";
  } | {
    /**
     * @generated from field: gathertown.SetSpeedModifier setSpeedModifier = 104;
     */
    value: SetSpeedModifier;
    case: "setSpeedModifier";
  } | {
    /**
     * @generated from field: gathertown.HighFive highFive = 105;
     */
    value: HighFive;
    case: "highFive";
  } | {
    /**
     * @generated from field: gathertown.SpaceUpdatesItems updateSpaceItems = 107;
     */
    value: SpaceUpdatesItems;
    case: "updateSpaceItems";
  } | {
    /**
     * @generated from field: gathertown.StopSound stopSound = 108;
     */
    value: StopSound;
    case: "stopSound";
  } | {
    /**
     * @generated from field: gathertown.HipToBeSquare hipToBeSquare = 109;
     */
    value: HipToBeSquare;
    case: "hipToBeSquare";
  } | {
    /**
     * @generated from field: gathertown.Craft craft = 110;
     */
    value: Craft;
    case: "craft";
  } | {
    /**
     * @generated from field: gathertown.TriggerInventoryItem triggerInventoryItem = 111;
     */
    value: TriggerInventoryItem;
    case: "triggerInventoryItem";
  } | {
    /**
     * @generated from field: gathertown.SetAllowScreenPointer setAllowScreenPointer = 112;
     */
    value: SetAllowScreenPointer;
    case: "setAllowScreenPointer";
  } | {
    /**
     * @generated from field: gathertown.PrecomputeEnter precomputeEnter = 113;
     */
    value: PrecomputeEnter;
    case: "precomputeEnter";
  } | {
    /**
     * @generated from field: gathertown.RequestMute requestMute = 114;
     */
    value: RequestMute;
    case: "requestMute";
  } | {
    /**
     * @generated from field: gathertown.SetDeskInfo setDeskInfo = 115;
     */
    value: SetDeskInfo;
    case: "setDeskInfo";
  } | {
    /**
     * @generated from field: gathertown.MapSetNooks mapSetNooks = 116;
     */
    value: MapSetNooks;
    case: "mapSetNooks";
  } | {
    /**
     * @generated from field: gathertown.RequestToJoinNook requestToJoinNook = 117;
     */
    value: RequestToJoinNook;
    case: "requestToJoinNook";
  } | {
    /**
     * @generated from field: gathertown.UpdateNookPermission updateNookPermission = 118;
     */
    value: UpdateNookPermission;
    case: "updateNookPermission";
  } | {
    /**
     * @generated from field: gathertown.Wave wave = 119;
     */
    value: Wave;
    case: "wave";
  } | {
    /**
     * @generated from field: gathertown.SetPronouns setPronouns = 120;
     */
    value: SetPronouns;
    case: "setPronouns";
  } | {
    /**
     * @generated from field: gathertown.SetTitle setTitle = 121;
     */
    value: SetTitle;
    case: "setTitle";
  } | {
    /**
     * @generated from field: gathertown.SetTimezone setTimezone = 122;
     */
    value: SetTimezone;
    case: "setTimezone";
  } | {
    /**
     * @generated from field: gathertown.SetPhone setPhone = 123;
     */
    value: SetPhone;
    case: "setPhone";
  } | {
    /**
     * @generated from field: gathertown.SetDescription setDescription = 124;
     */
    value: SetDescription;
    case: "setDescription";
  } | {
    /**
     * @generated from field: gathertown.SetProfileImageUrl setProfileImageUrl = 125;
     */
    value: SetProfileImageUrl;
    case: "setProfileImageUrl";
  } | {
    /**
     * @generated from field: gathertown.SetPersonalImageUrl setPersonalImageUrl = 126;
     */
    value: SetPersonalImageUrl;
    case: "setPersonalImageUrl";
  } | {
    /**
     * @generated from field: gathertown.SetAway setAway = 127;
     */
    value: SetAway;
    case: "setAway";
  } | {
    /**
     * @generated from field: gathertown.SetCity setCity = 128;
     */
    value: SetCity;
    case: "setCity";
  } | {
    /**
     * @generated from field: gathertown.SetCountry setCountry = 129;
     */
    value: SetCountry;
    case: "setCountry";
  } | {
    /**
     * @generated from field: gathertown.SetStartDate setStartDate = 130;
     */
    value: SetStartDate;
    case: "setStartDate";
  } | {
    /**
     * @generated from field: gathertown.StartRecording startRecording = 131;
     */
    value: StartRecording;
    case: "startRecording";
  } | {
    /**
     * @generated from field: gathertown.RequestAccessViaCheckIn requestAccessViaCheckIn = 132;
     */
    value: RequestAccessViaCheckIn;
    case: "requestAccessViaCheckIn";
  } | {
    /**
     * @generated from field: gathertown.RespondToAccessRequest respondToAccessRequest = 133;
     */
    value: RespondToAccessRequest;
    case: "respondToAccessRequest";
  } | {
    /**
     * @generated from field: gathertown.SetAvailability setAvailability = 134;
     */
    value: SetAvailability;
    case: "setAvailability";
  } | {
    /**
     * @generated from field: gathertown.RespawnAtDesk respawnAtDesk = 137;
     */
    value: RespawnAtDesk;
    case: "respawnAtDesk";
  } | {
    /**
     * @generated from field: gathertown.SetDeskFromNextAvailableDesk setDeskFromNextAvailableDesk = 138;
     */
    value: SetDeskFromNextAvailableDesk;
    case: "setDeskFromNextAvailableDesk";
  } | {
    /**
     * @generated from field: gathertown.SetSpaceRolePermissionOverride setSpaceRolePermissionOverride = 139;
     */
    value: SetSpaceRolePermissionOverride;
    case: "setSpaceRolePermissionOverride";
  } | {
    /**
     * @generated from field: gathertown.SetCurrentlyEquippedWearables setCurrentlyEquippedWearables = 140;
     */
    value: SetCurrentlyEquippedWearables;
    case: "setCurrentlyEquippedWearables";
  } | {
    /**
     * @generated from field: gathertown.SetDisplayEmail setDisplayEmail = 141;
     */
    value: SetDisplayEmail;
    case: "setDisplayEmail";
  } | {
    /**
     * @generated from field: gathertown.MapDeleteObjectByKey mapDeleteObjectByKey = 142;
     */
    value: MapDeleteObjectByKey;
    case: "mapDeleteObjectByKey";
  } | {
    /**
     * @generated from field: gathertown.MapUpdateObjects mapUpdateObjects = 143;
     */
    value: MapUpdateObjects;
    case: "mapUpdateObjects";
  } | {
    /**
     * @generated from field: gathertown.InteractWithObject interactWithObject = 144;
     */
    value: InteractWithObject;
    case: "interactWithObject";
  } | {
    /**
     * @generated from field: gathertown.TriggerObject triggerObject = 145;
     */
    value: TriggerObject;
    case: "triggerObject";
  } | {
    /**
     * experimental
     *
     * @generated from field: gathertown.JoinChimeMeeting joinChimeMeeting = 146;
     */
    value: JoinChimeMeeting;
    case: "joinChimeMeeting";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ClientServerAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ClientServerAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 100, name: "txnId", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 1, name: "clientHeartbeat", kind: "message", T: ClientHeartbeat, oneof: "action" },
    { no: 2, name: "clientBackupHeartbeat", kind: "message", T: ClientBackupHeartbeat, oneof: "action" },
    { no: 3, name: "updateSubscriptions", kind: "message", T: UpdateSubscriptions, oneof: "action" },
    { no: 5, name: "move", kind: "message", T: Move, oneof: "action" },
    { no: 7, name: "setAffiliation", kind: "message", T: SetAffiliation, oneof: "action" },
    { no: 8, name: "setStatus", kind: "message", T: SetStatus, oneof: "action" },
    { no: 9, name: "spotlight", kind: "message", T: Spotlight, oneof: "action" },
    { no: 10, name: "ring", kind: "message", T: Ring, oneof: "action" },
    { no: 12, name: "ban", kind: "message", T: Ban, oneof: "action" },
    { no: 13, name: "kick", kind: "message", T: Kick, oneof: "action" },
    { no: 14, name: "setImpassable", kind: "message", T: SetImpassable, oneof: "action" },
    { no: 15, name: "chat", kind: "message", T: Chat, oneof: "action" },
    { no: 18, name: "interact", kind: "message", T: Deprecated, oneof: "action" },
    { no: 19, name: "enterWhisper", kind: "message", T: EnterWhisper, oneof: "action" },
    { no: 20, name: "leaveWhisper", kind: "message", T: LeaveWhisper, oneof: "action" },
    { no: 21, name: "setEmojiStatus", kind: "message", T: SetEmojiStatus, oneof: "action" },
    { no: 22, name: "activelySpeaking", kind: "message", T: ActivelySpeaking, oneof: "action" },
    { no: 24, name: "setName", kind: "message", T: SetName, oneof: "action" },
    { no: 25, name: "setTextStatus", kind: "message", T: SetTextStatus, oneof: "action" },
    { no: 26, name: "teleport", kind: "message", T: Teleport, oneof: "action" },
    { no: 27, name: "exit", kind: "message", T: Exit, oneof: "action" },
    { no: 28, name: "enter", kind: "message", T: Enter, oneof: "action" },
    { no: 29, name: "setWorkCondition", kind: "message", T: Deprecated, oneof: "action" },
    { no: 30, name: "respawn", kind: "message", T: Respawn, oneof: "action" },
    { no: 31, name: "spawn", kind: "message", T: Spawn, oneof: "action" },
    { no: 32, name: "ghost", kind: "message", T: Ghost, oneof: "action" },
    { no: 33, name: "init", kind: "message", T: Init, oneof: "action" },
    { no: 34, name: "setOutfitString", kind: "message", T: Deprecated, oneof: "action" },
    { no: 36, name: "shootConfetti", kind: "message", T: ShootConfetti, oneof: "action" },
    { no: 37, name: "setEventStatus", kind: "message", T: SetEventStatus, oneof: "action" },
    { no: 38, name: "setInConversation", kind: "message", T: SetInConversation, oneof: "action" },
    { no: 39, name: "setCurrentDesk", kind: "message", T: Deprecated, oneof: "action" },
    { no: 40, name: "setCurrentArea", kind: "message", T: SetCurrentArea, oneof: "action" },
    { no: 41, name: "setImagePointer", kind: "message", T: SetImagePointer, oneof: "action" },
    { no: 42, name: "setGoKartId", kind: "message", T: Deprecated, oneof: "action" },
    { no: 43, name: "mapSetDimensions", kind: "message", T: MapSetDimensions, oneof: "action" },
    { no: 44, name: "mapSetCollisions", kind: "message", T: MapSetCollisions, oneof: "action" },
    { no: 45, name: "mapSetBackgroundImagePath", kind: "message", T: MapSetBackgroundImagePath, oneof: "action" },
    { no: 46, name: "mapSetForegroundImagePath", kind: "message", T: MapSetForegroundImagePath, oneof: "action" },
    { no: 47, name: "mapSetSprites", kind: "message", T: Deprecated, oneof: "action" },
    { no: 48, name: "mapSetSpawns", kind: "message", T: MapSetSpawns, oneof: "action" },
    { no: 49, name: "mapSetSpaces", kind: "message", T: Deprecated, oneof: "action" },
    { no: 50, name: "mapSetPortals", kind: "message", T: MapSetPortals, oneof: "action" },
    { no: 51, name: "mapSetAnnouncer", kind: "message", T: MapSetAnnouncer, oneof: "action" },
    { no: 54, name: "mapSetAssets", kind: "message", T: MapSetAssets, oneof: "action" },
    { no: 55, name: "mapSetObjects", kind: "message", T: Deprecated, oneof: "action" },
    { no: 56, name: "mapSetName", kind: "message", T: MapSetName, oneof: "action" },
    { no: 58, name: "mapSetMuteOnEntry", kind: "message", T: MapSetMuteOnEntry, oneof: "action" },
    { no: 59, name: "mapSetUseDrawnBG", kind: "message", T: MapSetUseDrawnBG, oneof: "action" },
    { no: 60, name: "mapSetWalls", kind: "message", T: MapSetWalls, oneof: "action" },
    { no: 61, name: "mapSetFloors", kind: "message", T: MapSetFloors, oneof: "action" },
    { no: 62, name: "mapSetAreas", kind: "message", T: MapSetAreas, oneof: "action" },
    { no: 63, name: "mapAddObject", kind: "message", T: MapAddObject, oneof: "action" },
    { no: 64, name: "mapDeleteObject", kind: "message", T: Deprecated, oneof: "action" },
    { no: 65, name: "mapSetSpawn", kind: "message", T: MapSetSpawn, oneof: "action" },
    { no: 66, name: "setIsAlone", kind: "message", T: SetIsAlone, oneof: "action" },
    { no: 67, name: "mapSetMiniMapImagePath", kind: "message", T: MapSetMiniMapImagePath, oneof: "action" },
    { no: 68, name: "mapSetEnabledChats", kind: "message", T: MapSetEnabledChats, oneof: "action" },
    { no: 69, name: "mapSetDescription", kind: "message", T: MapSetDescription, oneof: "action" },
    { no: 70, name: "mapSetDecoration", kind: "message", T: MapSetDecoration, oneof: "action" },
    { no: 71, name: "mapSetTutorialTasks", kind: "message", T: MapSetTutorialTasks, oneof: "action" },
    { no: 72, name: "playSound", kind: "message", T: PlaySound, oneof: "action" },
    { no: 73, name: "mapSetScript", kind: "message", T: MapSetScript, oneof: "action" },
    { no: 75, name: "setIsMobile", kind: "message", T: SetIsMobile, oneof: "action" },
    { no: 76, name: "setScreenPointer", kind: "message", T: SetScreenPointer, oneof: "action" },
    { no: 77, name: "setEmoteV2", kind: "message", T: SetEmoteV2, oneof: "action" },
    { no: 78, name: "setFocusModeEndTime", kind: "message", T: SetFocusModeEndTime, oneof: "action" },
    { no: 79, name: "mapDeleteObjectById", kind: "message", T: MapDeleteObjectById, oneof: "action" },
    { no: 80, name: "customAction", kind: "message", T: CustomAction, oneof: "action" },
    { no: 82, name: "block", kind: "message", T: Block, oneof: "action" },
    { no: 83, name: "setItemString", kind: "message", T: SetItemString, oneof: "action" },
    { no: 84, name: "triggerItem", kind: "message", T: Deprecated, oneof: "action" },
    { no: 85, name: "notify", kind: "message", T: Notify, oneof: "action" },
    { no: 86, name: "setFollowTarget", kind: "message", T: SetFollowTarget, oneof: "action" },
    { no: 87, name: "requestToLead", kind: "message", T: RequestToLead, oneof: "action" },
    { no: 88, name: "enterPortal", kind: "message", T: EnterPortal, oneof: "action" },
    { no: 89, name: "setManualVideoSrc", kind: "message", T: SetManualVideoSrc, oneof: "action" },
    { no: 90, name: "setSubtitle", kind: "message", T: SetSubtitle, oneof: "action" },
    { no: 91, name: "playerUpdatesSession", kind: "message", T: Deprecated, oneof: "action" },
    { no: 92, name: "mapMoveObject", kind: "message", T: MapMoveObject, oneof: "action" },
    { no: 93, name: "chatMessageUpdated", kind: "message", T: ChatMessageUpdated, oneof: "action" },
    { no: 94, name: "fxShakeObject", kind: "message", T: FXShakeObject, oneof: "action" },
    { no: 95, name: "fxShakeCamera", kind: "message", T: FXShakeCamera, oneof: "action" },
    { no: 96, name: "registerCommand", kind: "message", T: RegisterCommand, oneof: "action" },
    { no: 97, name: "sendCommand", kind: "message", T: SendCommand, oneof: "action" },
    { no: 98, name: "speakerUpdatesSession", kind: "message", T: SpeakerUpdatesSession, oneof: "action" },
    { no: 101, name: "addInventoryItem", kind: "message", T: AddInventoryItem, oneof: "action" },
    { no: 102, name: "removeInventoryItem", kind: "message", T: RemoveInventoryItem, oneof: "action" },
    { no: 103, name: "setVehicleId", kind: "message", T: SetVehicleId, oneof: "action" },
    { no: 104, name: "setSpeedModifier", kind: "message", T: SetSpeedModifier, oneof: "action" },
    { no: 105, name: "highFive", kind: "message", T: HighFive, oneof: "action" },
    { no: 107, name: "updateSpaceItems", kind: "message", T: SpaceUpdatesItems, oneof: "action" },
    { no: 108, name: "stopSound", kind: "message", T: StopSound, oneof: "action" },
    { no: 109, name: "hipToBeSquare", kind: "message", T: HipToBeSquare, oneof: "action" },
    { no: 110, name: "craft", kind: "message", T: Craft, oneof: "action" },
    { no: 111, name: "triggerInventoryItem", kind: "message", T: TriggerInventoryItem, oneof: "action" },
    { no: 112, name: "setAllowScreenPointer", kind: "message", T: SetAllowScreenPointer, oneof: "action" },
    { no: 113, name: "precomputeEnter", kind: "message", T: PrecomputeEnter, oneof: "action" },
    { no: 114, name: "requestMute", kind: "message", T: RequestMute, oneof: "action" },
    { no: 115, name: "setDeskInfo", kind: "message", T: SetDeskInfo, oneof: "action" },
    { no: 116, name: "mapSetNooks", kind: "message", T: MapSetNooks, oneof: "action" },
    { no: 117, name: "requestToJoinNook", kind: "message", T: RequestToJoinNook, oneof: "action" },
    { no: 118, name: "updateNookPermission", kind: "message", T: UpdateNookPermission, oneof: "action" },
    { no: 119, name: "wave", kind: "message", T: Wave, oneof: "action" },
    { no: 120, name: "setPronouns", kind: "message", T: SetPronouns, oneof: "action" },
    { no: 121, name: "setTitle", kind: "message", T: SetTitle, oneof: "action" },
    { no: 122, name: "setTimezone", kind: "message", T: SetTimezone, oneof: "action" },
    { no: 123, name: "setPhone", kind: "message", T: SetPhone, oneof: "action" },
    { no: 124, name: "setDescription", kind: "message", T: SetDescription, oneof: "action" },
    { no: 125, name: "setProfileImageUrl", kind: "message", T: SetProfileImageUrl, oneof: "action" },
    { no: 126, name: "setPersonalImageUrl", kind: "message", T: SetPersonalImageUrl, oneof: "action" },
    { no: 127, name: "setAway", kind: "message", T: SetAway, oneof: "action" },
    { no: 128, name: "setCity", kind: "message", T: SetCity, oneof: "action" },
    { no: 129, name: "setCountry", kind: "message", T: SetCountry, oneof: "action" },
    { no: 130, name: "setStartDate", kind: "message", T: SetStartDate, oneof: "action" },
    { no: 131, name: "startRecording", kind: "message", T: StartRecording, oneof: "action" },
    { no: 132, name: "requestAccessViaCheckIn", kind: "message", T: RequestAccessViaCheckIn, oneof: "action" },
    { no: 133, name: "respondToAccessRequest", kind: "message", T: RespondToAccessRequest, oneof: "action" },
    { no: 134, name: "setAvailability", kind: "message", T: SetAvailability, oneof: "action" },
    { no: 137, name: "respawnAtDesk", kind: "message", T: RespawnAtDesk, oneof: "action" },
    { no: 138, name: "setDeskFromNextAvailableDesk", kind: "message", T: SetDeskFromNextAvailableDesk, oneof: "action" },
    { no: 139, name: "setSpaceRolePermissionOverride", kind: "message", T: SetSpaceRolePermissionOverride, oneof: "action" },
    { no: 140, name: "setCurrentlyEquippedWearables", kind: "message", T: SetCurrentlyEquippedWearables, oneof: "action" },
    { no: 141, name: "setDisplayEmail", kind: "message", T: SetDisplayEmail, oneof: "action" },
    { no: 142, name: "mapDeleteObjectByKey", kind: "message", T: MapDeleteObjectByKey, oneof: "action" },
    { no: 143, name: "mapUpdateObjects", kind: "message", T: MapUpdateObjects, oneof: "action" },
    { no: 144, name: "interactWithObject", kind: "message", T: InteractWithObject, oneof: "action" },
    { no: 145, name: "triggerObject", kind: "message", T: TriggerObject, oneof: "action" },
    { no: 146, name: "joinChimeMeeting", kind: "message", T: JoinChimeMeeting, oneof: "action" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientServerAction {
    return new ClientServerAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientServerAction {
    return new ClientServerAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientServerAction {
    return new ClientServerAction().fromJsonString(jsonString, options);
  }

  static equals(a: ClientServerAction | PlainMessage<ClientServerAction> | undefined, b: ClientServerAction | PlainMessage<ClientServerAction> | undefined): boolean {
    return proto3.util.equals(ClientServerAction, a, b);
  }
}

/**
 * tbh this is half heartbeat half for measuring ping
 *
 * @generated from message gathertown.ClientHeartbeat
 */
export class ClientHeartbeat extends Message<ClientHeartbeat> {
  constructor(data?: PartialMessage<ClientHeartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ClientHeartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientHeartbeat {
    return new ClientHeartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientHeartbeat {
    return new ClientHeartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientHeartbeat {
    return new ClientHeartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: ClientHeartbeat | PlainMessage<ClientHeartbeat> | undefined, b: ClientHeartbeat | PlainMessage<ClientHeartbeat> | undefined): boolean {
    return proto3.util.equals(ClientHeartbeat, a, b);
  }
}

/**
 * this is because we've attached timings and stuff to the former one, don't want to interfere
 *
 * @generated from message gathertown.ClientBackupHeartbeat
 */
export class ClientBackupHeartbeat extends Message<ClientBackupHeartbeat> {
  constructor(data?: PartialMessage<ClientBackupHeartbeat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ClientBackupHeartbeat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientBackupHeartbeat {
    return new ClientBackupHeartbeat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientBackupHeartbeat {
    return new ClientBackupHeartbeat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientBackupHeartbeat {
    return new ClientBackupHeartbeat().fromJsonString(jsonString, options);
  }

  static equals(a: ClientBackupHeartbeat | PlainMessage<ClientBackupHeartbeat> | undefined, b: ClientBackupHeartbeat | PlainMessage<ClientBackupHeartbeat> | undefined): boolean {
    return proto3.util.equals(ClientBackupHeartbeat, a, b);
  }
}

/**
 * @generated from message gathertown.UpdateSubscriptions
 */
export class UpdateSubscriptions extends Message<UpdateSubscriptions> {
  /**
   * @generated from field: map<string, bool> subscriptions = 1;
   */
  subscriptions: { [key: string]: boolean } = {};

  /**
   * @generated from field: map<string, uint64> mapUpdateIds = 2;
   */
  mapUpdateIds: { [key: string]: bigint } = {};

  constructor(data?: PartialMessage<UpdateSubscriptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.UpdateSubscriptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscriptions", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 8 /* ScalarType.BOOL */} },
    { no: 2, name: "mapUpdateIds", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 4 /* ScalarType.UINT64 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSubscriptions {
    return new UpdateSubscriptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSubscriptions {
    return new UpdateSubscriptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSubscriptions {
    return new UpdateSubscriptions().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSubscriptions | PlainMessage<UpdateSubscriptions> | undefined, b: UpdateSubscriptions | PlainMessage<UpdateSubscriptions> | undefined): boolean {
    return proto3.util.equals(UpdateSubscriptions, a, b);
  }
}

/**
 * @generated from message gathertown.Move
 */
export class Move extends Message<Move> {
  /**
   * @generated from field: gathertown.MoveDirectionEnum.ENUM dir = 1;
   */
  dir = MoveDirectionEnum_ENUM.Left;

  /**
   * @generated from field: bool stopped = 2;
   */
  stopped = false;

  /**
   * @generated from field: uint32 inputId = 3;
   */
  inputId = 0;

  /**
   * @generated from field: optional string targetId = 4;
   */
  targetId?: string;

  constructor(data?: PartialMessage<Move>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Move";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dir", kind: "enum", T: proto3.getEnumType(MoveDirectionEnum_ENUM) },
    { no: 2, name: "stopped", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "inputId", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Move {
    return new Move().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Move {
    return new Move().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Move {
    return new Move().fromJsonString(jsonString, options);
  }

  static equals(a: Move | PlainMessage<Move> | undefined, b: Move | PlainMessage<Move> | undefined): boolean {
    return proto3.util.equals(Move, a, b);
  }
}

/**
 * @generated from message gathertown.RequestMute
 */
export class RequestMute extends Message<RequestMute> {
  /**
   * @generated from field: string target = 1;
   */
  target = "";

  /**
   * @generated from field: bool video = 2;
   */
  video = false;

  constructor(data?: PartialMessage<RequestMute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RequestMute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "video", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestMute {
    return new RequestMute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestMute {
    return new RequestMute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestMute {
    return new RequestMute().fromJsonString(jsonString, options);
  }

  static equals(a: RequestMute | PlainMessage<RequestMute> | undefined, b: RequestMute | PlainMessage<RequestMute> | undefined): boolean {
    return proto3.util.equals(RequestMute, a, b);
  }
}

/**
 * @generated from message gathertown.SetAffiliation
 */
export class SetAffiliation extends Message<SetAffiliation> {
  /**
   * @generated from field: string affiliation = 1;
   */
  affiliation = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetAffiliation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetAffiliation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "affiliation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetAffiliation {
    return new SetAffiliation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetAffiliation {
    return new SetAffiliation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetAffiliation {
    return new SetAffiliation().fromJsonString(jsonString, options);
  }

  static equals(a: SetAffiliation | PlainMessage<SetAffiliation> | undefined, b: SetAffiliation | PlainMessage<SetAffiliation> | undefined): boolean {
    return proto3.util.equals(SetAffiliation, a, b);
  }
}

/**
 * @generated from message gathertown.SetStatus
 */
export class SetStatus extends Message<SetStatus> {
  /**
   * @generated from field: bool status = 1;
   */
  status = false;

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetStatus {
    return new SetStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetStatus {
    return new SetStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetStatus {
    return new SetStatus().fromJsonString(jsonString, options);
  }

  static equals(a: SetStatus | PlainMessage<SetStatus> | undefined, b: SetStatus | PlainMessage<SetStatus> | undefined): boolean {
    return proto3.util.equals(SetStatus, a, b);
  }
}

/**
 * @generated from message gathertown.SetAvailability
 */
export class SetAvailability extends Message<SetAvailability> {
  /**
   * @generated from field: string availability = 1;
   */
  availability = "";

  /**
   * @generated from field: optional string endOption = 2;
   */
  endOption?: string;

  constructor(data?: PartialMessage<SetAvailability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetAvailability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "availability", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "endOption", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetAvailability {
    return new SetAvailability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetAvailability {
    return new SetAvailability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetAvailability {
    return new SetAvailability().fromJsonString(jsonString, options);
  }

  static equals(a: SetAvailability | PlainMessage<SetAvailability> | undefined, b: SetAvailability | PlainMessage<SetAvailability> | undefined): boolean {
    return proto3.util.equals(SetAvailability, a, b);
  }
}

/**
 * @generated from message gathertown.SetCurrentlyEquippedWearables
 */
export class SetCurrentlyEquippedWearables extends Message<SetCurrentlyEquippedWearables> {
  /**
   * @generated from field: gathertown.DBOutfit currentlyEquippedWearables = 1;
   */
  currentlyEquippedWearables?: DBOutfit;

  /**
   * @generated from field: optional string targetId = 3;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetCurrentlyEquippedWearables>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetCurrentlyEquippedWearables";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currentlyEquippedWearables", kind: "message", T: DBOutfit },
    { no: 3, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetCurrentlyEquippedWearables {
    return new SetCurrentlyEquippedWearables().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetCurrentlyEquippedWearables {
    return new SetCurrentlyEquippedWearables().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetCurrentlyEquippedWearables {
    return new SetCurrentlyEquippedWearables().fromJsonString(jsonString, options);
  }

  static equals(a: SetCurrentlyEquippedWearables | PlainMessage<SetCurrentlyEquippedWearables> | undefined, b: SetCurrentlyEquippedWearables | PlainMessage<SetCurrentlyEquippedWearables> | undefined): boolean {
    return proto3.util.equals(SetCurrentlyEquippedWearables, a, b);
  }
}

/**
 * @generated from message gathertown.Spotlight
 */
export class Spotlight extends Message<Spotlight> {
  /**
   * @generated from field: string spotlightedUser = 1;
   */
  spotlightedUser = "";

  /**
   * @generated from field: bool isSpotlighted = 2;
   */
  isSpotlighted = false;

  constructor(data?: PartialMessage<Spotlight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Spotlight";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spotlightedUser", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isSpotlighted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Spotlight {
    return new Spotlight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Spotlight {
    return new Spotlight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Spotlight {
    return new Spotlight().fromJsonString(jsonString, options);
  }

  static equals(a: Spotlight | PlainMessage<Spotlight> | undefined, b: Spotlight | PlainMessage<Spotlight> | undefined): boolean {
    return proto3.util.equals(Spotlight, a, b);
  }
}

/**
 * @generated from message gathertown.Ring
 */
export class Ring extends Message<Ring> {
  /**
   * @generated from field: string user = 1;
   */
  user = "";

  constructor(data?: PartialMessage<Ring>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Ring";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ring {
    return new Ring().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ring {
    return new Ring().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ring {
    return new Ring().fromJsonString(jsonString, options);
  }

  static equals(a: Ring | PlainMessage<Ring> | undefined, b: Ring | PlainMessage<Ring> | undefined): boolean {
    return proto3.util.equals(Ring, a, b);
  }
}

/**
 * @generated from message gathertown.SetImagePointer
 */
export class SetImagePointer extends Message<SetImagePointer> {
  /**
   * @generated from field: string objectId = 1;
   */
  objectId = "";

  /**
   * @generated from field: double x = 2;
   */
  x = 0;

  /**
   * @generated from field: double y = 3;
   */
  y = 0;

  constructor(data?: PartialMessage<SetImagePointer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetImagePointer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objectId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetImagePointer {
    return new SetImagePointer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetImagePointer {
    return new SetImagePointer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetImagePointer {
    return new SetImagePointer().fromJsonString(jsonString, options);
  }

  static equals(a: SetImagePointer | PlainMessage<SetImagePointer> | undefined, b: SetImagePointer | PlainMessage<SetImagePointer> | undefined): boolean {
    return proto3.util.equals(SetImagePointer, a, b);
  }
}

/**
 * @generated from message gathertown.SetScreenPointer
 */
export class SetScreenPointer extends Message<SetScreenPointer> {
  /**
   * @generated from field: string screenId = 1;
   */
  screenId = "";

  /**
   * @generated from field: double x = 2;
   */
  x = 0;

  /**
   * @generated from field: double y = 3;
   */
  y = 0;

  constructor(data?: PartialMessage<SetScreenPointer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetScreenPointer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "screenId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "x", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "y", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetScreenPointer {
    return new SetScreenPointer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetScreenPointer {
    return new SetScreenPointer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetScreenPointer {
    return new SetScreenPointer().fromJsonString(jsonString, options);
  }

  static equals(a: SetScreenPointer | PlainMessage<SetScreenPointer> | undefined, b: SetScreenPointer | PlainMessage<SetScreenPointer> | undefined): boolean {
    return proto3.util.equals(SetScreenPointer, a, b);
  }
}

/**
 * @generated from message gathertown.Ban
 */
export class Ban extends Message<Ban> {
  /**
   * @generated from field: string user = 1;
   */
  user = "";

  constructor(data?: PartialMessage<Ban>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Ban";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ban {
    return new Ban().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ban {
    return new Ban().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ban {
    return new Ban().fromJsonString(jsonString, options);
  }

  static equals(a: Ban | PlainMessage<Ban> | undefined, b: Ban | PlainMessage<Ban> | undefined): boolean {
    return proto3.util.equals(Ban, a, b);
  }
}

/**
 * @generated from message gathertown.Kick
 */
export class Kick extends Message<Kick> {
  /**
   * @generated from field: string user = 1;
   */
  user = "";

  constructor(data?: PartialMessage<Kick>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Kick";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Kick {
    return new Kick().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Kick {
    return new Kick().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Kick {
    return new Kick().fromJsonString(jsonString, options);
  }

  static equals(a: Kick | PlainMessage<Kick> | undefined, b: Kick | PlainMessage<Kick> | undefined): boolean {
    return proto3.util.equals(Kick, a, b);
  }
}

/**
 * @generated from message gathertown.Block
 */
export class Block extends Message<Block> {
  /**
   * @generated from field: string blockedUserId = 1;
   */
  blockedUserId = "";

  /**
   * @generated from field: bool blocked = 2;
   */
  blocked = false;

  constructor(data?: PartialMessage<Block>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Block";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blockedUserId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "blocked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Block {
    return new Block().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJsonString(jsonString, options);
  }

  static equals(a: Block | PlainMessage<Block> | undefined, b: Block | PlainMessage<Block> | undefined): boolean {
    return proto3.util.equals(Block, a, b);
  }
}

/**
 * @generated from message gathertown.SetImpassable
 */
export class SetImpassable extends Message<SetImpassable> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: uint32 x = 2;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 3;
   */
  y = 0;

  /**
   * @generated from field: bool impassable = 4;
   */
  impassable = false;

  constructor(data?: PartialMessage<SetImpassable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetImpassable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "impassable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetImpassable {
    return new SetImpassable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetImpassable {
    return new SetImpassable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetImpassable {
    return new SetImpassable().fromJsonString(jsonString, options);
  }

  static equals(a: SetImpassable | PlainMessage<SetImpassable> | undefined, b: SetImpassable | PlainMessage<SetImpassable> | undefined): boolean {
    return proto3.util.equals(SetImpassable, a, b);
  }
}

/**
 * @generated from message gathertown.Chat
 */
export class Chat extends Message<Chat> {
  /**
   * @generated from field: string chatRecipient = 1;
   */
  chatRecipient = "";

  /**
   * @generated from field: string contents = 2;
   */
  contents = "";

  /**
   * @generated from field: repeated string localPlayerIds = 3;
   */
  localPlayerIds: string[] = [];

  /**
   * @generated from field: string mapId = 4;
   */
  mapId = "";

  /**
   * @generated from field: optional string id = 5;
   */
  id?: string;

  /**
   * @generated from field: optional string nookId = 6;
   */
  nookId?: string;

  constructor(data?: PartialMessage<Chat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Chat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chatRecipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "localPlayerIds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "nookId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Chat {
    return new Chat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Chat {
    return new Chat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Chat {
    return new Chat().fromJsonString(jsonString, options);
  }

  static equals(a: Chat | PlainMessage<Chat> | undefined, b: Chat | PlainMessage<Chat> | undefined): boolean {
    return proto3.util.equals(Chat, a, b);
  }
}

/**
 * @generated from message gathertown.Notify
 */
export class Notify extends Message<Notify> {
  /**
   * @generated from field: string notification = 1;
   */
  notification = "";

  constructor(data?: PartialMessage<Notify>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Notify";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "notification", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Notify {
    return new Notify().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Notify {
    return new Notify().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Notify {
    return new Notify().fromJsonString(jsonString, options);
  }

  static equals(a: Notify | PlainMessage<Notify> | undefined, b: Notify | PlainMessage<Notify> | undefined): boolean {
    return proto3.util.equals(Notify, a, b);
  }
}

/**
 * @generated from message gathertown.InteractWithObject
 */
export class InteractWithObject extends Message<InteractWithObject> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: string key = 2;
   */
  key = "";

  /**
   * JSON string. Really this should be a separate "submit" action
   *
   * @generated from field: optional string dataJson = 3;
   */
  dataJson?: string;

  constructor(data?: PartialMessage<InteractWithObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.InteractWithObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "dataJson", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InteractWithObject {
    return new InteractWithObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InteractWithObject {
    return new InteractWithObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InteractWithObject {
    return new InteractWithObject().fromJsonString(jsonString, options);
  }

  static equals(a: InteractWithObject | PlainMessage<InteractWithObject> | undefined, b: InteractWithObject | PlainMessage<InteractWithObject> | undefined): boolean {
    return proto3.util.equals(InteractWithObject, a, b);
  }
}

/**
 * @generated from message gathertown.ActivelySpeaking
 */
export class ActivelySpeaking extends Message<ActivelySpeaking> {
  /**
   * @generated from field: bool activelySpeaking = 1;
   */
  activelySpeaking = false;

  constructor(data?: PartialMessage<ActivelySpeaking>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ActivelySpeaking";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "activelySpeaking", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivelySpeaking {
    return new ActivelySpeaking().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivelySpeaking {
    return new ActivelySpeaking().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivelySpeaking {
    return new ActivelySpeaking().fromJsonString(jsonString, options);
  }

  static equals(a: ActivelySpeaking | PlainMessage<ActivelySpeaking> | undefined, b: ActivelySpeaking | PlainMessage<ActivelySpeaking> | undefined): boolean {
    return proto3.util.equals(ActivelySpeaking, a, b);
  }
}

/**
 * @generated from message gathertown.EnterWhisper
 */
export class EnterWhisper extends Message<EnterWhisper> {
  /**
   * @generated from field: string recipientId = 1;
   */
  recipientId = "";

  /**
   * @generated from field: gathertown.MoveDirectionEnum.ENUM dir = 2;
   */
  dir = MoveDirectionEnum_ENUM.Left;

  constructor(data?: PartialMessage<EnterWhisper>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.EnterWhisper";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "recipientId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dir", kind: "enum", T: proto3.getEnumType(MoveDirectionEnum_ENUM) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnterWhisper {
    return new EnterWhisper().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnterWhisper {
    return new EnterWhisper().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnterWhisper {
    return new EnterWhisper().fromJsonString(jsonString, options);
  }

  static equals(a: EnterWhisper | PlainMessage<EnterWhisper> | undefined, b: EnterWhisper | PlainMessage<EnterWhisper> | undefined): boolean {
    return proto3.util.equals(EnterWhisper, a, b);
  }
}

/**
 * @generated from message gathertown.LeaveWhisper
 */
export class LeaveWhisper extends Message<LeaveWhisper> {
  constructor(data?: PartialMessage<LeaveWhisper>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.LeaveWhisper";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LeaveWhisper {
    return new LeaveWhisper().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LeaveWhisper {
    return new LeaveWhisper().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LeaveWhisper {
    return new LeaveWhisper().fromJsonString(jsonString, options);
  }

  static equals(a: LeaveWhisper | PlainMessage<LeaveWhisper> | undefined, b: LeaveWhisper | PlainMessage<LeaveWhisper> | undefined): boolean {
    return proto3.util.equals(LeaveWhisper, a, b);
  }
}

/**
 * @generated from message gathertown.Ghost
 */
export class Ghost extends Message<Ghost> {
  /**
   * @generated from field: uint32 ghost = 1;
   */
  ghost = 0;

  /**
   * why is this a uint32? it is in the original impl so.. it stays
   *
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<Ghost>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Ghost";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ghost", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ghost {
    return new Ghost().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ghost {
    return new Ghost().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ghost {
    return new Ghost().fromJsonString(jsonString, options);
  }

  static equals(a: Ghost | PlainMessage<Ghost> | undefined, b: Ghost | PlainMessage<Ghost> | undefined): boolean {
    return proto3.util.equals(Ghost, a, b);
  }
}

/**
 * @generated from message gathertown.SetEmoteV2
 */
export class SetEmoteV2 extends Message<SetEmoteV2> {
  /**
   * @generated from field: optional string emote = 1;
   */
  emote?: string;

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  /**
   * @generated from field: optional uint32 count = 3;
   */
  count?: number;

  constructor(data?: PartialMessage<SetEmoteV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetEmoteV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "emote", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetEmoteV2 {
    return new SetEmoteV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetEmoteV2 {
    return new SetEmoteV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetEmoteV2 {
    return new SetEmoteV2().fromJsonString(jsonString, options);
  }

  static equals(a: SetEmoteV2 | PlainMessage<SetEmoteV2> | undefined, b: SetEmoteV2 | PlainMessage<SetEmoteV2> | undefined): boolean {
    return proto3.util.equals(SetEmoteV2, a, b);
  }
}

/**
 * @generated from message gathertown.SetName
 */
export class SetName extends Message<SetName> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetName";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetName {
    return new SetName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetName {
    return new SetName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetName {
    return new SetName().fromJsonString(jsonString, options);
  }

  static equals(a: SetName | PlainMessage<SetName> | undefined, b: SetName | PlainMessage<SetName> | undefined): boolean {
    return proto3.util.equals(SetName, a, b);
  }
}

/**
 * @generated from message gathertown.SetTextStatus
 */
export class SetTextStatus extends Message<SetTextStatus> {
  /**
   * @generated from field: string textStatus = 1;
   */
  textStatus = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetTextStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetTextStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "textStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetTextStatus {
    return new SetTextStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetTextStatus {
    return new SetTextStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetTextStatus {
    return new SetTextStatus().fromJsonString(jsonString, options);
  }

  static equals(a: SetTextStatus | PlainMessage<SetTextStatus> | undefined, b: SetTextStatus | PlainMessage<SetTextStatus> | undefined): boolean {
    return proto3.util.equals(SetTextStatus, a, b);
  }
}

/**
 * @generated from message gathertown.SetPronouns
 */
export class SetPronouns extends Message<SetPronouns> {
  /**
   * @generated from field: string pronouns = 1;
   */
  pronouns = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetPronouns>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetPronouns";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pronouns", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetPronouns {
    return new SetPronouns().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetPronouns {
    return new SetPronouns().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetPronouns {
    return new SetPronouns().fromJsonString(jsonString, options);
  }

  static equals(a: SetPronouns | PlainMessage<SetPronouns> | undefined, b: SetPronouns | PlainMessage<SetPronouns> | undefined): boolean {
    return proto3.util.equals(SetPronouns, a, b);
  }
}

/**
 * @generated from message gathertown.SetTitle
 */
export class SetTitle extends Message<SetTitle> {
  /**
   * @generated from field: string title = 1;
   */
  title = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetTitle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetTitle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "title", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetTitle {
    return new SetTitle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetTitle {
    return new SetTitle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetTitle {
    return new SetTitle().fromJsonString(jsonString, options);
  }

  static equals(a: SetTitle | PlainMessage<SetTitle> | undefined, b: SetTitle | PlainMessage<SetTitle> | undefined): boolean {
    return proto3.util.equals(SetTitle, a, b);
  }
}

/**
 * @generated from message gathertown.SetCity
 */
export class SetCity extends Message<SetCity> {
  /**
   * @generated from field: string city = 1;
   */
  city = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetCity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetCity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "city", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetCity {
    return new SetCity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetCity {
    return new SetCity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetCity {
    return new SetCity().fromJsonString(jsonString, options);
  }

  static equals(a: SetCity | PlainMessage<SetCity> | undefined, b: SetCity | PlainMessage<SetCity> | undefined): boolean {
    return proto3.util.equals(SetCity, a, b);
  }
}

/**
 * @generated from message gathertown.SetCountry
 */
export class SetCountry extends Message<SetCountry> {
  /**
   * @generated from field: string country = 1;
   */
  country = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetCountry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetCountry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "country", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetCountry {
    return new SetCountry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetCountry {
    return new SetCountry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetCountry {
    return new SetCountry().fromJsonString(jsonString, options);
  }

  static equals(a: SetCountry | PlainMessage<SetCountry> | undefined, b: SetCountry | PlainMessage<SetCountry> | undefined): boolean {
    return proto3.util.equals(SetCountry, a, b);
  }
}

/**
 * @generated from message gathertown.SetStartDate
 */
export class SetStartDate extends Message<SetStartDate> {
  /**
   * @generated from field: string startDate = 1;
   */
  startDate = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetStartDate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetStartDate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "startDate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetStartDate {
    return new SetStartDate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetStartDate {
    return new SetStartDate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetStartDate {
    return new SetStartDate().fromJsonString(jsonString, options);
  }

  static equals(a: SetStartDate | PlainMessage<SetStartDate> | undefined, b: SetStartDate | PlainMessage<SetStartDate> | undefined): boolean {
    return proto3.util.equals(SetStartDate, a, b);
  }
}

/**
 * @generated from message gathertown.SetTimezone
 */
export class SetTimezone extends Message<SetTimezone> {
  /**
   * @generated from field: string timezone = 1;
   */
  timezone = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetTimezone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetTimezone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timezone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetTimezone {
    return new SetTimezone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetTimezone {
    return new SetTimezone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetTimezone {
    return new SetTimezone().fromJsonString(jsonString, options);
  }

  static equals(a: SetTimezone | PlainMessage<SetTimezone> | undefined, b: SetTimezone | PlainMessage<SetTimezone> | undefined): boolean {
    return proto3.util.equals(SetTimezone, a, b);
  }
}

/**
 * @generated from message gathertown.SetPhone
 */
export class SetPhone extends Message<SetPhone> {
  /**
   * @generated from field: string phone = 1;
   */
  phone = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetPhone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetPhone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetPhone {
    return new SetPhone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetPhone {
    return new SetPhone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetPhone {
    return new SetPhone().fromJsonString(jsonString, options);
  }

  static equals(a: SetPhone | PlainMessage<SetPhone> | undefined, b: SetPhone | PlainMessage<SetPhone> | undefined): boolean {
    return proto3.util.equals(SetPhone, a, b);
  }
}

/**
 * @generated from message gathertown.SetDisplayEmail
 */
export class SetDisplayEmail extends Message<SetDisplayEmail> {
  /**
   * @generated from field: string displayEmail = 1;
   */
  displayEmail = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetDisplayEmail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetDisplayEmail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "displayEmail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetDisplayEmail {
    return new SetDisplayEmail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetDisplayEmail {
    return new SetDisplayEmail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetDisplayEmail {
    return new SetDisplayEmail().fromJsonString(jsonString, options);
  }

  static equals(a: SetDisplayEmail | PlainMessage<SetDisplayEmail> | undefined, b: SetDisplayEmail | PlainMessage<SetDisplayEmail> | undefined): boolean {
    return proto3.util.equals(SetDisplayEmail, a, b);
  }
}

/**
 * @generated from message gathertown.SetDescription
 */
export class SetDescription extends Message<SetDescription> {
  /**
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetDescription {
    return new SetDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetDescription {
    return new SetDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetDescription {
    return new SetDescription().fromJsonString(jsonString, options);
  }

  static equals(a: SetDescription | PlainMessage<SetDescription> | undefined, b: SetDescription | PlainMessage<SetDescription> | undefined): boolean {
    return proto3.util.equals(SetDescription, a, b);
  }
}

/**
 * @generated from message gathertown.SetProfileImageUrl
 */
export class SetProfileImageUrl extends Message<SetProfileImageUrl> {
  /**
   * @generated from field: string profileImageUrl = 1;
   */
  profileImageUrl = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetProfileImageUrl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetProfileImageUrl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "profileImageUrl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetProfileImageUrl {
    return new SetProfileImageUrl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetProfileImageUrl {
    return new SetProfileImageUrl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetProfileImageUrl {
    return new SetProfileImageUrl().fromJsonString(jsonString, options);
  }

  static equals(a: SetProfileImageUrl | PlainMessage<SetProfileImageUrl> | undefined, b: SetProfileImageUrl | PlainMessage<SetProfileImageUrl> | undefined): boolean {
    return proto3.util.equals(SetProfileImageUrl, a, b);
  }
}

/**
 * @generated from message gathertown.SetPersonalImageUrl
 */
export class SetPersonalImageUrl extends Message<SetPersonalImageUrl> {
  /**
   * @generated from field: string personalImageUrl = 1;
   */
  personalImageUrl = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetPersonalImageUrl>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetPersonalImageUrl";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "personalImageUrl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetPersonalImageUrl {
    return new SetPersonalImageUrl().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetPersonalImageUrl {
    return new SetPersonalImageUrl().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetPersonalImageUrl {
    return new SetPersonalImageUrl().fromJsonString(jsonString, options);
  }

  static equals(a: SetPersonalImageUrl | PlainMessage<SetPersonalImageUrl> | undefined, b: SetPersonalImageUrl | PlainMessage<SetPersonalImageUrl> | undefined): boolean {
    return proto3.util.equals(SetPersonalImageUrl, a, b);
  }
}

/**
 * @generated from message gathertown.Exit
 */
export class Exit extends Message<Exit> {
  constructor(data?: PartialMessage<Exit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Exit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Exit {
    return new Exit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Exit {
    return new Exit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Exit {
    return new Exit().fromJsonString(jsonString, options);
  }

  static equals(a: Exit | PlainMessage<Exit> | undefined, b: Exit | PlainMessage<Exit> | undefined): boolean {
    return proto3.util.equals(Exit, a, b);
  }
}

/**
 * @generated from message gathertown.Enter
 */
export class Enter extends Message<Enter> {
  /**
   * @generated from field: optional gathertown.PlayerInitInfo info = 1;
   */
  info?: PlayerInitInfo;

  /**
   * @generated from field: optional string spawnToken = 2;
   */
  spawnToken?: string;

  /**
   * @generated from field: optional string targetId = 3;
   */
  targetId?: string;

  constructor(data?: PartialMessage<Enter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Enter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info", kind: "message", T: PlayerInitInfo, opt: true },
    { no: 2, name: "spawnToken", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Enter {
    return new Enter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Enter {
    return new Enter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Enter {
    return new Enter().fromJsonString(jsonString, options);
  }

  static equals(a: Enter | PlainMessage<Enter> | undefined, b: Enter | PlainMessage<Enter> | undefined): boolean {
    return proto3.util.equals(Enter, a, b);
  }
}

/**
 * @generated from message gathertown.PrecomputeEnter
 */
export class PrecomputeEnter extends Message<PrecomputeEnter> {
  /**
   * @generated from field: optional gathertown.MapLocation enterLocation = 1;
   */
  enterLocation?: MapLocation;

  /**
   * @generated from field: optional string spawnToken = 2;
   */
  spawnToken?: string;

  constructor(data?: PartialMessage<PrecomputeEnter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PrecomputeEnter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enterLocation", kind: "message", T: MapLocation, opt: true },
    { no: 2, name: "spawnToken", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrecomputeEnter {
    return new PrecomputeEnter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrecomputeEnter {
    return new PrecomputeEnter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrecomputeEnter {
    return new PrecomputeEnter().fromJsonString(jsonString, options);
  }

  static equals(a: PrecomputeEnter | PlainMessage<PrecomputeEnter> | undefined, b: PrecomputeEnter | PlainMessage<PrecomputeEnter> | undefined): boolean {
    return proto3.util.equals(PrecomputeEnter, a, b);
  }
}

/**
 * @generated from message gathertown.SetEmojiStatus
 */
export class SetEmojiStatus extends Message<SetEmojiStatus> {
  /**
   * @generated from field: string emojiStatus = 1;
   */
  emojiStatus = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetEmojiStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetEmojiStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "emojiStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetEmojiStatus {
    return new SetEmojiStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetEmojiStatus {
    return new SetEmojiStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetEmojiStatus {
    return new SetEmojiStatus().fromJsonString(jsonString, options);
  }

  static equals(a: SetEmojiStatus | PlainMessage<SetEmojiStatus> | undefined, b: SetEmojiStatus | PlainMessage<SetEmojiStatus> | undefined): boolean {
    return proto3.util.equals(SetEmojiStatus, a, b);
  }
}

/**
 * @generated from message gathertown.Teleport
 */
export class Teleport extends Message<Teleport> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: uint32 x = 2;
   */
  x = 0;

  /**
   * @generated from field: uint32 y = 3;
   */
  y = 0;

  /**
   * @generated from field: optional string targetId = 4;
   */
  targetId?: string;

  /**
   * @generated from field: optional gathertown.SpriteDirectionEnum.ENUM direction = 5;
   */
  direction?: SpriteDirectionEnum_ENUM;

  constructor(data?: PartialMessage<Teleport>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Teleport";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "direction", kind: "enum", T: proto3.getEnumType(SpriteDirectionEnum_ENUM), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Teleport {
    return new Teleport().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Teleport {
    return new Teleport().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Teleport {
    return new Teleport().fromJsonString(jsonString, options);
  }

  static equals(a: Teleport | PlainMessage<Teleport> | undefined, b: Teleport | PlainMessage<Teleport> | undefined): boolean {
    return proto3.util.equals(Teleport, a, b);
  }
}

/**
 * @generated from message gathertown.Spawn
 */
export class Spawn extends Message<Spawn> {
  /**
   * @generated from field: string spawnToken = 1;
   */
  spawnToken = "";

  constructor(data?: PartialMessage<Spawn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Spawn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spawnToken", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Spawn {
    return new Spawn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Spawn {
    return new Spawn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Spawn {
    return new Spawn().fromJsonString(jsonString, options);
  }

  static equals(a: Spawn | PlainMessage<Spawn> | undefined, b: Spawn | PlainMessage<Spawn> | undefined): boolean {
    return proto3.util.equals(Spawn, a, b);
  }
}

/**
 * @generated from message gathertown.Respawn
 */
export class Respawn extends Message<Respawn> {
  constructor(data?: PartialMessage<Respawn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Respawn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Respawn {
    return new Respawn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Respawn {
    return new Respawn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Respawn {
    return new Respawn().fromJsonString(jsonString, options);
  }

  static equals(a: Respawn | PlainMessage<Respawn> | undefined, b: Respawn | PlainMessage<Respawn> | undefined): boolean {
    return proto3.util.equals(Respawn, a, b);
  }
}

/**
 * @generated from message gathertown.RespawnAtDesk
 */
export class RespawnAtDesk extends Message<RespawnAtDesk> {
  constructor(data?: PartialMessage<RespawnAtDesk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RespawnAtDesk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespawnAtDesk {
    return new RespawnAtDesk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespawnAtDesk {
    return new RespawnAtDesk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespawnAtDesk {
    return new RespawnAtDesk().fromJsonString(jsonString, options);
  }

  static equals(a: RespawnAtDesk | PlainMessage<RespawnAtDesk> | undefined, b: RespawnAtDesk | PlainMessage<RespawnAtDesk> | undefined): boolean {
    return proto3.util.equals(RespawnAtDesk, a, b);
  }
}

/**
 * @generated from message gathertown.RequestToJoinNook
 */
export class RequestToJoinNook extends Message<RequestToJoinNook> {
  /**
   * @generated from field: string nookId = 1;
   */
  nookId = "";

  /**
   * @generated from field: string mapId = 2;
   */
  mapId = "";

  /**
   * @generated from field: optional string name = 3;
   */
  name?: string;

  constructor(data?: PartialMessage<RequestToJoinNook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RequestToJoinNook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nookId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestToJoinNook {
    return new RequestToJoinNook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestToJoinNook {
    return new RequestToJoinNook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestToJoinNook {
    return new RequestToJoinNook().fromJsonString(jsonString, options);
  }

  static equals(a: RequestToJoinNook | PlainMessage<RequestToJoinNook> | undefined, b: RequestToJoinNook | PlainMessage<RequestToJoinNook> | undefined): boolean {
    return proto3.util.equals(RequestToJoinNook, a, b);
  }
}

/**
 * @generated from message gathertown.UpdateNookPermission
 */
export class UpdateNookPermission extends Message<UpdateNookPermission> {
  /**
   * @generated from field: string playerId = 1;
   */
  playerId = "";

  /**
   * @generated from field: string nookId = 2;
   */
  nookId = "";

  /**
   * @generated from field: bool granted = 3;
   */
  granted = false;

  constructor(data?: PartialMessage<UpdateNookPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.UpdateNookPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "playerId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nookId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "granted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateNookPermission {
    return new UpdateNookPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateNookPermission {
    return new UpdateNookPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateNookPermission {
    return new UpdateNookPermission().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateNookPermission | PlainMessage<UpdateNookPermission> | undefined, b: UpdateNookPermission | PlainMessage<UpdateNookPermission> | undefined): boolean {
    return proto3.util.equals(UpdateNookPermission, a, b);
  }
}

/**
 * @generated from message gathertown.Init
 */
export class Init extends Message<Init> {
  /**
   * @generated from field: string spaceId = 1;
   */
  spaceId = "";

  /**
   * @generated from oneof gathertown.Init.auth
   */
  auth: {
    /**
     * @generated from field: string token = 2;
     */
    value: string;
    case: "token";
  } | {
    /**
     * @generated from field: string apiKey = 3;
     */
    value: string;
    case: "apiKey";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Init>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Init";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spaceId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "auth" },
    { no: 3, name: "apiKey", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "auth" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Init {
    return new Init().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Init {
    return new Init().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Init {
    return new Init().fromJsonString(jsonString, options);
  }

  static equals(a: Init | PlainMessage<Init> | undefined, b: Init | PlainMessage<Init> | undefined): boolean {
    return proto3.util.equals(Init, a, b);
  }
}

/**
 * @generated from message gathertown.MapAddObject
 */
export class MapAddObject extends Message<MapAddObject> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: gathertown.WireObject object = 2;
   */
  object?: WireObject;

  constructor(data?: PartialMessage<MapAddObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapAddObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object", kind: "message", T: WireObject },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapAddObject {
    return new MapAddObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapAddObject {
    return new MapAddObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapAddObject {
    return new MapAddObject().fromJsonString(jsonString, options);
  }

  static equals(a: MapAddObject | PlainMessage<MapAddObject> | undefined, b: MapAddObject | PlainMessage<MapAddObject> | undefined): boolean {
    return proto3.util.equals(MapAddObject, a, b);
  }
}

/**
 * @generated from message gathertown.MapUpdateObjects
 */
export class MapUpdateObjects extends Message<MapUpdateObjects> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: map<string, gathertown.WireObject> objects = 2;
   */
  objects: { [key: string]: WireObject } = {};

  /**
   * @generated from field: optional bool updatesAreOverwrites = 3;
   */
  updatesAreOverwrites?: boolean;

  constructor(data?: PartialMessage<MapUpdateObjects>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapUpdateObjects";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "objects", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: WireObject} },
    { no: 3, name: "updatesAreOverwrites", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapUpdateObjects {
    return new MapUpdateObjects().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapUpdateObjects {
    return new MapUpdateObjects().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapUpdateObjects {
    return new MapUpdateObjects().fromJsonString(jsonString, options);
  }

  static equals(a: MapUpdateObjects | PlainMessage<MapUpdateObjects> | undefined, b: MapUpdateObjects | PlainMessage<MapUpdateObjects> | undefined): boolean {
    return proto3.util.equals(MapUpdateObjects, a, b);
  }
}

/**
 * @generated from message gathertown.ShootConfetti
 */
export class ShootConfetti extends Message<ShootConfetti> {
  /**
   * @generated from field: optional string targetId = 1;
   */
  targetId?: string;

  constructor(data?: PartialMessage<ShootConfetti>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ShootConfetti";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShootConfetti {
    return new ShootConfetti().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShootConfetti {
    return new ShootConfetti().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShootConfetti {
    return new ShootConfetti().fromJsonString(jsonString, options);
  }

  static equals(a: ShootConfetti | PlainMessage<ShootConfetti> | undefined, b: ShootConfetti | PlainMessage<ShootConfetti> | undefined): boolean {
    return proto3.util.equals(ShootConfetti, a, b);
  }
}

/**
 * @generated from message gathertown.SetEventStatus
 */
export class SetEventStatus extends Message<SetEventStatus> {
  /**
   * @generated from field: string eventStatus = 1;
   */
  eventStatus = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetEventStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetEventStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "eventStatus", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetEventStatus {
    return new SetEventStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetEventStatus {
    return new SetEventStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetEventStatus {
    return new SetEventStatus().fromJsonString(jsonString, options);
  }

  static equals(a: SetEventStatus | PlainMessage<SetEventStatus> | undefined, b: SetEventStatus | PlainMessage<SetEventStatus> | undefined): boolean {
    return proto3.util.equals(SetEventStatus, a, b);
  }
}

/**
 * @generated from message gathertown.SetInConversation
 */
export class SetInConversation extends Message<SetInConversation> {
  /**
   * @generated from field: bool inConversation = 1;
   */
  inConversation = false;

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetInConversation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetInConversation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inConversation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetInConversation {
    return new SetInConversation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetInConversation {
    return new SetInConversation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetInConversation {
    return new SetInConversation().fromJsonString(jsonString, options);
  }

  static equals(a: SetInConversation | PlainMessage<SetInConversation> | undefined, b: SetInConversation | PlainMessage<SetInConversation> | undefined): boolean {
    return proto3.util.equals(SetInConversation, a, b);
  }
}

/**
 * @generated from message gathertown.SetCurrentArea
 */
export class SetCurrentArea extends Message<SetCurrentArea> {
  /**
   * @generated from field: string currentArea = 1;
   */
  currentArea = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetCurrentArea>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetCurrentArea";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currentArea", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetCurrentArea {
    return new SetCurrentArea().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetCurrentArea {
    return new SetCurrentArea().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetCurrentArea {
    return new SetCurrentArea().fromJsonString(jsonString, options);
  }

  static equals(a: SetCurrentArea | PlainMessage<SetCurrentArea> | undefined, b: SetCurrentArea | PlainMessage<SetCurrentArea> | undefined): boolean {
    return proto3.util.equals(SetCurrentArea, a, b);
  }
}

/**
 * @generated from message gathertown.SetVehicleId
 */
export class SetVehicleId extends Message<SetVehicleId> {
  /**
   * @generated from field: string vehicleId = 1;
   */
  vehicleId = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  /**
   * @generated from field: optional string action = 3;
   */
  action?: string;

  constructor(data?: PartialMessage<SetVehicleId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetVehicleId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vehicleId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "action", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetVehicleId {
    return new SetVehicleId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetVehicleId {
    return new SetVehicleId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetVehicleId {
    return new SetVehicleId().fromJsonString(jsonString, options);
  }

  static equals(a: SetVehicleId | PlainMessage<SetVehicleId> | undefined, b: SetVehicleId | PlainMessage<SetVehicleId> | undefined): boolean {
    return proto3.util.equals(SetVehicleId, a, b);
  }
}

/**
 * @generated from message gathertown.SetSpeedModifier
 */
export class SetSpeedModifier extends Message<SetSpeedModifier> {
  /**
   * @generated from field: float speedModifier = 1;
   */
  speedModifier = 0;

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetSpeedModifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetSpeedModifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "speedModifier", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetSpeedModifier {
    return new SetSpeedModifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetSpeedModifier {
    return new SetSpeedModifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetSpeedModifier {
    return new SetSpeedModifier().fromJsonString(jsonString, options);
  }

  static equals(a: SetSpeedModifier | PlainMessage<SetSpeedModifier> | undefined, b: SetSpeedModifier | PlainMessage<SetSpeedModifier> | undefined): boolean {
    return proto3.util.equals(SetSpeedModifier, a, b);
  }
}

/**
 * @generated from message gathertown.SetIsAlone
 */
export class SetIsAlone extends Message<SetIsAlone> {
  /**
   * @generated from field: bool isAlone = 1;
   */
  isAlone = false;

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetIsAlone>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetIsAlone";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "isAlone", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetIsAlone {
    return new SetIsAlone().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetIsAlone {
    return new SetIsAlone().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetIsAlone {
    return new SetIsAlone().fromJsonString(jsonString, options);
  }

  static equals(a: SetIsAlone | PlainMessage<SetIsAlone> | undefined, b: SetIsAlone | PlainMessage<SetIsAlone> | undefined): boolean {
    return proto3.util.equals(SetIsAlone, a, b);
  }
}

/**
 * @generated from message gathertown.SetIsMobile
 */
export class SetIsMobile extends Message<SetIsMobile> {
  /**
   * @generated from field: bool isMobile = 1;
   */
  isMobile = false;

  constructor(data?: PartialMessage<SetIsMobile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetIsMobile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "isMobile", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetIsMobile {
    return new SetIsMobile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetIsMobile {
    return new SetIsMobile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetIsMobile {
    return new SetIsMobile().fromJsonString(jsonString, options);
  }

  static equals(a: SetIsMobile | PlainMessage<SetIsMobile> | undefined, b: SetIsMobile | PlainMessage<SetIsMobile> | undefined): boolean {
    return proto3.util.equals(SetIsMobile, a, b);
  }
}

/**
 * @generated from message gathertown.PlaySound
 */
export class PlaySound extends Message<PlaySound> {
  /**
   * @generated from field: string src = 1;
   */
  src = "";

  /**
   * @generated from field: float volume = 2;
   */
  volume = 0;

  /**
   * @generated from field: optional string targetId = 3;
   */
  targetId?: string;

  constructor(data?: PartialMessage<PlaySound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.PlaySound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "src", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "volume", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PlaySound {
    return new PlaySound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PlaySound {
    return new PlaySound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PlaySound {
    return new PlaySound().fromJsonString(jsonString, options);
  }

  static equals(a: PlaySound | PlainMessage<PlaySound> | undefined, b: PlaySound | PlainMessage<PlaySound> | undefined): boolean {
    return proto3.util.equals(PlaySound, a, b);
  }
}

/**
 * @generated from message gathertown.StopSound
 */
export class StopSound extends Message<StopSound> {
  /**
   * @generated from field: string src = 1;
   */
  src = "";

  /**
   * @generated from field: optional string targetId = 3;
   */
  targetId?: string;

  constructor(data?: PartialMessage<StopSound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.StopSound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "src", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StopSound {
    return new StopSound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StopSound {
    return new StopSound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StopSound {
    return new StopSound().fromJsonString(jsonString, options);
  }

  static equals(a: StopSound | PlainMessage<StopSound> | undefined, b: StopSound | PlainMessage<StopSound> | undefined): boolean {
    return proto3.util.equals(StopSound, a, b);
  }
}

/**
 * @generated from message gathertown.SetFocusModeEndTime
 */
export class SetFocusModeEndTime extends Message<SetFocusModeEndTime> {
  /**
   * @generated from field: string focusModeEndTime = 1;
   */
  focusModeEndTime = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetFocusModeEndTime>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetFocusModeEndTime";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "focusModeEndTime", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetFocusModeEndTime {
    return new SetFocusModeEndTime().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetFocusModeEndTime {
    return new SetFocusModeEndTime().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetFocusModeEndTime {
    return new SetFocusModeEndTime().fromJsonString(jsonString, options);
  }

  static equals(a: SetFocusModeEndTime | PlainMessage<SetFocusModeEndTime> | undefined, b: SetFocusModeEndTime | PlainMessage<SetFocusModeEndTime> | undefined): boolean {
    return proto3.util.equals(SetFocusModeEndTime, a, b);
  }
}

/**
 * @generated from message gathertown.SetItemString
 */
export class SetItemString extends Message<SetItemString> {
  /**
   * @generated from field: string itemString = 1;
   */
  itemString = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetItemString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetItemString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "itemString", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetItemString {
    return new SetItemString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetItemString {
    return new SetItemString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetItemString {
    return new SetItemString().fromJsonString(jsonString, options);
  }

  static equals(a: SetItemString | PlainMessage<SetItemString> | undefined, b: SetItemString | PlainMessage<SetItemString> | undefined): boolean {
    return proto3.util.equals(SetItemString, a, b);
  }
}

/**
 * @generated from message gathertown.TriggerObject
 */
export class TriggerObject extends Message<TriggerObject> {
  /**
   * @generated from field: optional string mapId = 1;
   */
  mapId?: string;

  /**
   * @generated from field: optional string key = 2;
   */
  key?: string;

  constructor(data?: PartialMessage<TriggerObject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.TriggerObject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TriggerObject {
    return new TriggerObject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TriggerObject {
    return new TriggerObject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TriggerObject {
    return new TriggerObject().fromJsonString(jsonString, options);
  }

  static equals(a: TriggerObject | PlainMessage<TriggerObject> | undefined, b: TriggerObject | PlainMessage<TriggerObject> | undefined): boolean {
    return proto3.util.equals(TriggerObject, a, b);
  }
}

/**
 * @generated from message gathertown.CustomAction
 */
export class CustomAction extends Message<CustomAction> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string payload = 2;
   */
  payload = "";

  /**
   * @generated from field: repeated string recipients = 3;
   */
  recipients: string[] = [];

  /**
   * @generated from field: optional bool sendToAll = 4;
   */
  sendToAll?: boolean;

  constructor(data?: PartialMessage<CustomAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.CustomAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payload", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "recipients", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "sendToAll", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomAction {
    return new CustomAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomAction {
    return new CustomAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomAction {
    return new CustomAction().fromJsonString(jsonString, options);
  }

  static equals(a: CustomAction | PlainMessage<CustomAction> | undefined, b: CustomAction | PlainMessage<CustomAction> | undefined): boolean {
    return proto3.util.equals(CustomAction, a, b);
  }
}

/**
 * @generated from message gathertown.SetFollowTarget
 */
export class SetFollowTarget extends Message<SetFollowTarget> {
  /**
   * @generated from field: string followTarget = 1;
   */
  followTarget = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetFollowTarget>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetFollowTarget";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "followTarget", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetFollowTarget {
    return new SetFollowTarget().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetFollowTarget {
    return new SetFollowTarget().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetFollowTarget {
    return new SetFollowTarget().fromJsonString(jsonString, options);
  }

  static equals(a: SetFollowTarget | PlainMessage<SetFollowTarget> | undefined, b: SetFollowTarget | PlainMessage<SetFollowTarget> | undefined): boolean {
    return proto3.util.equals(SetFollowTarget, a, b);
  }
}

/**
 * @generated from message gathertown.RequestToLead
 */
export class RequestToLead extends Message<RequestToLead> {
  /**
   * @generated from field: string target = 1;
   */
  target = "";

  /**
   * @generated from field: string snapshot = 2;
   */
  snapshot = "";

  constructor(data?: PartialMessage<RequestToLead>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RequestToLead";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "snapshot", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestToLead {
    return new RequestToLead().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestToLead {
    return new RequestToLead().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestToLead {
    return new RequestToLead().fromJsonString(jsonString, options);
  }

  static equals(a: RequestToLead | PlainMessage<RequestToLead> | undefined, b: RequestToLead | PlainMessage<RequestToLead> | undefined): boolean {
    return proto3.util.equals(RequestToLead, a, b);
  }
}

/**
 * @generated from message gathertown.EnterPortal
 */
export class EnterPortal extends Message<EnterPortal> {
  /**
   * @generated from field: string targetUrl = 1;
   */
  targetUrl = "";

  /**
   * @generated from field: optional bool bypassPrompt = 2;
   */
  bypassPrompt?: boolean;

  /**
   * @generated from field: optional string targetId = 3;
   */
  targetId?: string;

  constructor(data?: PartialMessage<EnterPortal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.EnterPortal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "targetUrl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bypassPrompt", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnterPortal {
    return new EnterPortal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnterPortal {
    return new EnterPortal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnterPortal {
    return new EnterPortal().fromJsonString(jsonString, options);
  }

  static equals(a: EnterPortal | PlainMessage<EnterPortal> | undefined, b: EnterPortal | PlainMessage<EnterPortal> | undefined): boolean {
    return proto3.util.equals(EnterPortal, a, b);
  }
}

/**
 * @generated from message gathertown.SetManualVideoSrc
 */
export class SetManualVideoSrc extends Message<SetManualVideoSrc> {
  /**
   * @generated from field: string manualVideoSrc = 1;
   */
  manualVideoSrc = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetManualVideoSrc>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetManualVideoSrc";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "manualVideoSrc", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetManualVideoSrc {
    return new SetManualVideoSrc().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetManualVideoSrc {
    return new SetManualVideoSrc().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetManualVideoSrc {
    return new SetManualVideoSrc().fromJsonString(jsonString, options);
  }

  static equals(a: SetManualVideoSrc | PlainMessage<SetManualVideoSrc> | undefined, b: SetManualVideoSrc | PlainMessage<SetManualVideoSrc> | undefined): boolean {
    return proto3.util.equals(SetManualVideoSrc, a, b);
  }
}

/**
 * @generated from message gathertown.SetSubtitle
 */
export class SetSubtitle extends Message<SetSubtitle> {
  /**
   * @generated from field: string subtitle = 1;
   */
  subtitle = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetSubtitle>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetSubtitle";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subtitle", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetSubtitle {
    return new SetSubtitle().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetSubtitle {
    return new SetSubtitle().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetSubtitle {
    return new SetSubtitle().fromJsonString(jsonString, options);
  }

  static equals(a: SetSubtitle | PlainMessage<SetSubtitle> | undefined, b: SetSubtitle | PlainMessage<SetSubtitle> | undefined): boolean {
    return proto3.util.equals(SetSubtitle, a, b);
  }
}

/**
 * @generated from message gathertown.MapCommitsChanges
 */
export class MapCommitsChanges extends Message<MapCommitsChanges> {
  /**
   * @generated from field: string mapId = 1;
   */
  mapId = "";

  /**
   * @generated from field: uint64 updateId = 2;
   */
  updateId = protoInt64.zero;

  constructor(data?: PartialMessage<MapCommitsChanges>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.MapCommitsChanges";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "updateId", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MapCommitsChanges {
    return new MapCommitsChanges().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MapCommitsChanges {
    return new MapCommitsChanges().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MapCommitsChanges {
    return new MapCommitsChanges().fromJsonString(jsonString, options);
  }

  static equals(a: MapCommitsChanges | PlainMessage<MapCommitsChanges> | undefined, b: MapCommitsChanges | PlainMessage<MapCommitsChanges> | undefined): boolean {
    return proto3.util.equals(MapCommitsChanges, a, b);
  }
}

/**
 * @generated from message gathertown.SpeakerUpdatesSession
 */
export class SpeakerUpdatesSession extends Message<SpeakerUpdatesSession> {
  /**
   * @generated from field: string sessionId = 1;
   */
  sessionId = "";

  /**
   * @generated from field: optional bool customizeRoomEnabled = 2;
   */
  customizeRoomEnabled?: boolean;

  /**
   * @generated from field: optional bool chatEnabled = 3;
   */
  chatEnabled?: boolean;

  /**
   * @generated from field: optional bool qaEnabled = 4;
   */
  qaEnabled?: boolean;

  /**
   * @generated from field: optional bool approveQuestionsEnabled = 5;
   */
  approveQuestionsEnabled?: boolean;

  /**
   * @generated from field: optional bool massMuteEnabled = 6;
   */
  massMuteEnabled?: boolean;

  constructor(data?: PartialMessage<SpeakerUpdatesSession>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SpeakerUpdatesSession";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sessionId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "customizeRoomEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "chatEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "qaEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 5, name: "approveQuestionsEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "massMuteEnabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpeakerUpdatesSession {
    return new SpeakerUpdatesSession().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpeakerUpdatesSession {
    return new SpeakerUpdatesSession().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpeakerUpdatesSession {
    return new SpeakerUpdatesSession().fromJsonString(jsonString, options);
  }

  static equals(a: SpeakerUpdatesSession | PlainMessage<SpeakerUpdatesSession> | undefined, b: SpeakerUpdatesSession | PlainMessage<SpeakerUpdatesSession> | undefined): boolean {
    return proto3.util.equals(SpeakerUpdatesSession, a, b);
  }
}

/**
 * @generated from message gathertown.ChatReply
 */
export class ChatReply extends Message<ChatReply> {
  /**
   * @generated from field: string senderId = 1;
   */
  senderId = "";

  /**
   * @generated from field: string senderName = 2;
   */
  senderName = "";

  /**
   * @generated from field: string contents = 3;
   */
  contents = "";

  constructor(data?: PartialMessage<ChatReply>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ChatReply";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "senderId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "senderName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatReply {
    return new ChatReply().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatReply {
    return new ChatReply().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatReply {
    return new ChatReply().fromJsonString(jsonString, options);
  }

  static equals(a: ChatReply | PlainMessage<ChatReply> | undefined, b: ChatReply | PlainMessage<ChatReply> | undefined): boolean {
    return proto3.util.equals(ChatReply, a, b);
  }
}

/**
 * @generated from message gathertown.ChatMessageUpdated
 */
export class ChatMessageUpdated extends Message<ChatMessageUpdated> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<ChatMessageUpdated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.ChatMessageUpdated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChatMessageUpdated {
    return new ChatMessageUpdated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChatMessageUpdated {
    return new ChatMessageUpdated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChatMessageUpdated {
    return new ChatMessageUpdated().fromJsonString(jsonString, options);
  }

  static equals(a: ChatMessageUpdated | PlainMessage<ChatMessageUpdated> | undefined, b: ChatMessageUpdated | PlainMessage<ChatMessageUpdated> | undefined): boolean {
    return proto3.util.equals(ChatMessageUpdated, a, b);
  }
}

/**
 * @generated from message gathertown.SendCommand
 */
export class SendCommand extends Message<SendCommand> {
  /**
   * @generated from field: string command = 1;
   */
  command = "";

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SendCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SendCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendCommand {
    return new SendCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendCommand {
    return new SendCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendCommand {
    return new SendCommand().fromJsonString(jsonString, options);
  }

  static equals(a: SendCommand | PlainMessage<SendCommand> | undefined, b: SendCommand | PlainMessage<SendCommand> | undefined): boolean {
    return proto3.util.equals(SendCommand, a, b);
  }
}

/**
 * @generated from message gathertown.RegisterCommand
 */
export class RegisterCommand extends Message<RegisterCommand> {
  /**
   * @generated from field: string command = 1;
   */
  command = "";

  constructor(data?: PartialMessage<RegisterCommand>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RegisterCommand";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "command", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterCommand {
    return new RegisterCommand().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterCommand {
    return new RegisterCommand().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterCommand {
    return new RegisterCommand().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterCommand | PlainMessage<RegisterCommand> | undefined, b: RegisterCommand | PlainMessage<RegisterCommand> | undefined): boolean {
    return proto3.util.equals(RegisterCommand, a, b);
  }
}

/**
 * @generated from message gathertown.Craft
 */
export class Craft extends Message<Craft> {
  /**
   * @generated from field: map<string, int32> inputs = 1;
   */
  inputs: { [key: string]: number } = {};

  constructor(data?: PartialMessage<Craft>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Craft";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inputs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 5 /* ScalarType.INT32 */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Craft {
    return new Craft().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Craft {
    return new Craft().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Craft {
    return new Craft().fromJsonString(jsonString, options);
  }

  static equals(a: Craft | PlainMessage<Craft> | undefined, b: Craft | PlainMessage<Craft> | undefined): boolean {
    return proto3.util.equals(Craft, a, b);
  }
}

/**
 * @generated from message gathertown.HighFive
 */
export class HighFive extends Message<HighFive> {
  /**
   * @generated from field: string targetId = 1;
   */
  targetId = "";

  /**
   * @generated from field: optional string emote = 2;
   */
  emote?: string;

  constructor(data?: PartialMessage<HighFive>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.HighFive";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "emote", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HighFive {
    return new HighFive().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HighFive {
    return new HighFive().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HighFive {
    return new HighFive().fromJsonString(jsonString, options);
  }

  static equals(a: HighFive | PlainMessage<HighFive> | undefined, b: HighFive | PlainMessage<HighFive> | undefined): boolean {
    return proto3.util.equals(HighFive, a, b);
  }
}

/**
 * @generated from message gathertown.AddInventoryItem
 */
export class AddInventoryItem extends Message<AddInventoryItem> {
  /**
   * @generated from field: string itemId = 1;
   */
  itemId = "";

  /**
   * @generated from field: uint64 delta = 2;
   */
  delta = protoInt64.zero;

  /**
   * @generated from field: string targetId = 3;
   */
  targetId = "";

  constructor(data?: PartialMessage<AddInventoryItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.AddInventoryItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "itemId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "delta", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddInventoryItem {
    return new AddInventoryItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddInventoryItem {
    return new AddInventoryItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddInventoryItem {
    return new AddInventoryItem().fromJsonString(jsonString, options);
  }

  static equals(a: AddInventoryItem | PlainMessage<AddInventoryItem> | undefined, b: AddInventoryItem | PlainMessage<AddInventoryItem> | undefined): boolean {
    return proto3.util.equals(AddInventoryItem, a, b);
  }
}

/**
 * @generated from message gathertown.RemoveInventoryItem
 */
export class RemoveInventoryItem extends Message<RemoveInventoryItem> {
  /**
   * @generated from field: string itemId = 1;
   */
  itemId = "";

  /**
   * @generated from field: uint64 delta = 2;
   */
  delta = protoInt64.zero;

  /**
   * @generated from field: optional string targetId = 3;
   */
  targetId?: string;

  constructor(data?: PartialMessage<RemoveInventoryItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RemoveInventoryItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "itemId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "delta", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveInventoryItem {
    return new RemoveInventoryItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveInventoryItem {
    return new RemoveInventoryItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveInventoryItem {
    return new RemoveInventoryItem().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveInventoryItem | PlainMessage<RemoveInventoryItem> | undefined, b: RemoveInventoryItem | PlainMessage<RemoveInventoryItem> | undefined): boolean {
    return proto3.util.equals(RemoveInventoryItem, a, b);
  }
}

/**
 * @generated from message gathertown.HipToBeSquare
 */
export class HipToBeSquare extends Message<HipToBeSquare> {
  /**
   * @generated from field: string data = 1;
   */
  data = "";

  constructor(data?: PartialMessage<HipToBeSquare>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.HipToBeSquare";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HipToBeSquare {
    return new HipToBeSquare().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HipToBeSquare {
    return new HipToBeSquare().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HipToBeSquare {
    return new HipToBeSquare().fromJsonString(jsonString, options);
  }

  static equals(a: HipToBeSquare | PlainMessage<HipToBeSquare> | undefined, b: HipToBeSquare | PlainMessage<HipToBeSquare> | undefined): boolean {
    return proto3.util.equals(HipToBeSquare, a, b);
  }
}

/**
 * @generated from message gathertown.TriggerInventoryItem
 */
export class TriggerInventoryItem extends Message<TriggerInventoryItem> {
  /**
   * @generated from field: string itemId = 1;
   */
  itemId = "";

  /**
   * @generated from field: string abilityId = 2;
   */
  abilityId = "";

  constructor(data?: PartialMessage<TriggerInventoryItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.TriggerInventoryItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "itemId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "abilityId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TriggerInventoryItem {
    return new TriggerInventoryItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TriggerInventoryItem {
    return new TriggerInventoryItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TriggerInventoryItem {
    return new TriggerInventoryItem().fromJsonString(jsonString, options);
  }

  static equals(a: TriggerInventoryItem | PlainMessage<TriggerInventoryItem> | undefined, b: TriggerInventoryItem | PlainMessage<TriggerInventoryItem> | undefined): boolean {
    return proto3.util.equals(TriggerInventoryItem, a, b);
  }
}

/**
 * @generated from message gathertown.SetAllowScreenPointer
 */
export class SetAllowScreenPointer extends Message<SetAllowScreenPointer> {
  /**
   * @generated from field: bool allowScreenPointer = 1;
   */
  allowScreenPointer = false;

  constructor(data?: PartialMessage<SetAllowScreenPointer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetAllowScreenPointer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowScreenPointer", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetAllowScreenPointer {
    return new SetAllowScreenPointer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetAllowScreenPointer {
    return new SetAllowScreenPointer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetAllowScreenPointer {
    return new SetAllowScreenPointer().fromJsonString(jsonString, options);
  }

  static equals(a: SetAllowScreenPointer | PlainMessage<SetAllowScreenPointer> | undefined, b: SetAllowScreenPointer | PlainMessage<SetAllowScreenPointer> | undefined): boolean {
    return proto3.util.equals(SetAllowScreenPointer, a, b);
  }
}

/**
 * @generated from message gathertown.SetDeskInfo
 */
export class SetDeskInfo extends Message<SetDeskInfo> {
  /**
   * @generated from field: gathertown.DeskInfoV2 deskInfo = 1;
   */
  deskInfo?: DeskInfoV2;

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetDeskInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetDeskInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deskInfo", kind: "message", T: DeskInfoV2 },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetDeskInfo {
    return new SetDeskInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetDeskInfo {
    return new SetDeskInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetDeskInfo {
    return new SetDeskInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SetDeskInfo | PlainMessage<SetDeskInfo> | undefined, b: SetDeskInfo | PlainMessage<SetDeskInfo> | undefined): boolean {
    return proto3.util.equals(SetDeskInfo, a, b);
  }
}

/**
 * @generated from message gathertown.Wave
 */
export class Wave extends Message<Wave> {
  /**
   * @generated from field: string user = 1;
   */
  user = "";

  /**
   * @generated from field: bool isReply = 2;
   */
  isReply = false;

  constructor(data?: PartialMessage<Wave>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.Wave";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isReply", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Wave {
    return new Wave().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Wave {
    return new Wave().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Wave {
    return new Wave().fromJsonString(jsonString, options);
  }

  static equals(a: Wave | PlainMessage<Wave> | undefined, b: Wave | PlainMessage<Wave> | undefined): boolean {
    return proto3.util.equals(Wave, a, b);
  }
}

/**
 * @generated from message gathertown.SetAway
 */
export class SetAway extends Message<SetAway> {
  /**
   * @generated from field: bool away = 1;
   */
  away = false;

  /**
   * @generated from field: optional string targetId = 2;
   */
  targetId?: string;

  constructor(data?: PartialMessage<SetAway>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetAway";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "away", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "targetId", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetAway {
    return new SetAway().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetAway {
    return new SetAway().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetAway {
    return new SetAway().fromJsonString(jsonString, options);
  }

  static equals(a: SetAway | PlainMessage<SetAway> | undefined, b: SetAway | PlainMessage<SetAway> | undefined): boolean {
    return proto3.util.equals(SetAway, a, b);
  }
}

/**
 * @generated from message gathertown.StartRecording
 */
export class StartRecording extends Message<StartRecording> {
  /**
   * @generated from field: string nookId = 1;
   */
  nookId = "";

  /**
   * @generated from field: optional bool initializing = 2;
   */
  initializing?: boolean;

  constructor(data?: PartialMessage<StartRecording>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.StartRecording";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nookId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initializing", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartRecording {
    return new StartRecording().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartRecording {
    return new StartRecording().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartRecording {
    return new StartRecording().fromJsonString(jsonString, options);
  }

  static equals(a: StartRecording | PlainMessage<StartRecording> | undefined, b: StartRecording | PlainMessage<StartRecording> | undefined): boolean {
    return proto3.util.equals(StartRecording, a, b);
  }
}

/**
 * @generated from message gathertown.RequestAccessViaCheckIn
 */
export class RequestAccessViaCheckIn extends Message<RequestAccessViaCheckIn> {
  /**
   * @generated from field: string userId = 1;
   */
  userId = "";

  /**
   * @generated from field: bool canceled = 2;
   */
  canceled = false;

  /**
   * @generated from field: optional string name = 3;
   */
  name?: string;

  /**
   * @generated from field: optional gathertown.DBOutfit currentlyEquippedWearables = 5;
   */
  currentlyEquippedWearables?: DBOutfit;

  constructor(data?: PartialMessage<RequestAccessViaCheckIn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RequestAccessViaCheckIn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "userId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "canceled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "currentlyEquippedWearables", kind: "message", T: DBOutfit, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestAccessViaCheckIn {
    return new RequestAccessViaCheckIn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestAccessViaCheckIn {
    return new RequestAccessViaCheckIn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestAccessViaCheckIn {
    return new RequestAccessViaCheckIn().fromJsonString(jsonString, options);
  }

  static equals(a: RequestAccessViaCheckIn | PlainMessage<RequestAccessViaCheckIn> | undefined, b: RequestAccessViaCheckIn | PlainMessage<RequestAccessViaCheckIn> | undefined): boolean {
    return proto3.util.equals(RequestAccessViaCheckIn, a, b);
  }
}

/**
 * @generated from message gathertown.RespondToAccessRequest
 */
export class RespondToAccessRequest extends Message<RespondToAccessRequest> {
  /**
   * @generated from field: string userId = 1;
   */
  userId = "";

  /**
   * @generated from field: bool accepted = 2;
   */
  accepted = false;

  /**
   * @generated from field: optional gathertown.RespondToAccessRequest.LocationTypeEnum locationType = 3;
   */
  locationType?: RespondToAccessRequest_LocationTypeEnum;

  constructor(data?: PartialMessage<RespondToAccessRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.RespondToAccessRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "userId", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "accepted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "locationType", kind: "enum", T: proto3.getEnumType(RespondToAccessRequest_LocationTypeEnum), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RespondToAccessRequest {
    return new RespondToAccessRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RespondToAccessRequest {
    return new RespondToAccessRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RespondToAccessRequest {
    return new RespondToAccessRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RespondToAccessRequest | PlainMessage<RespondToAccessRequest> | undefined, b: RespondToAccessRequest | PlainMessage<RespondToAccessRequest> | undefined): boolean {
    return proto3.util.equals(RespondToAccessRequest, a, b);
  }
}

/**
 * @generated from enum gathertown.RespondToAccessRequest.LocationTypeEnum
 */
export enum RespondToAccessRequest_LocationTypeEnum {
  /**
   * @generated from enum value: MyLocation = 0;
   */
  MyLocation = 0,

  /**
   * @generated from enum value: DefaultSpawn = 1;
   */
  DefaultSpawn = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RespondToAccessRequest_LocationTypeEnum)
proto3.util.setEnumType(RespondToAccessRequest_LocationTypeEnum, "gathertown.RespondToAccessRequest.LocationTypeEnum", [
  { no: 0, name: "MyLocation" },
  { no: 1, name: "DefaultSpawn" },
]);

/**
 * @generated from message gathertown.SetSpaceRolePermissionOverride
 */
export class SetSpaceRolePermissionOverride extends Message<SetSpaceRolePermissionOverride> {
  /**
   * @generated from field: string role = 1;
   */
  role = "";

  /**
   * @generated from field: string permission = 2;
   */
  permission = "";

  /**
   * @generated from field: bool enabled = 3;
   */
  enabled = false;

  constructor(data?: PartialMessage<SetSpaceRolePermissionOverride>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.SetSpaceRolePermissionOverride";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetSpaceRolePermissionOverride {
    return new SetSpaceRolePermissionOverride().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetSpaceRolePermissionOverride {
    return new SetSpaceRolePermissionOverride().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetSpaceRolePermissionOverride {
    return new SetSpaceRolePermissionOverride().fromJsonString(jsonString, options);
  }

  static equals(a: SetSpaceRolePermissionOverride | PlainMessage<SetSpaceRolePermissionOverride> | undefined, b: SetSpaceRolePermissionOverride | PlainMessage<SetSpaceRolePermissionOverride> | undefined): boolean {
    return proto3.util.equals(SetSpaceRolePermissionOverride, a, b);
  }
}

/**
 * @generated from message gathertown.JoinChimeMeeting
 */
export class JoinChimeMeeting extends Message<JoinChimeMeeting> {
  /**
   * @generated from field: optional string mediaRegion = 1;
   */
  mediaRegion?: string;

  constructor(data?: PartialMessage<JoinChimeMeeting>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gathertown.JoinChimeMeeting";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mediaRegion", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JoinChimeMeeting {
    return new JoinChimeMeeting().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JoinChimeMeeting {
    return new JoinChimeMeeting().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JoinChimeMeeting {
    return new JoinChimeMeeting().fromJsonString(jsonString, options);
  }

  static equals(a: JoinChimeMeeting | PlainMessage<JoinChimeMeeting> | undefined, b: JoinChimeMeeting | PlainMessage<JoinChimeMeeting> | undefined): boolean {
    return proto3.util.equals(JoinChimeMeeting, a, b);
  }
}

