import { PlayerInitInfo, ServerClientEvent } from "@gathertown/gather-game-common/dist/src/public/events";
import { GameWsCloseCode } from "@gathertown/gather-game-common/dist/src/public/responseCodes";
import { ClientServerActionAction } from "@gathertown/gather-game-common/dist/src/public/utils";
import { SlidingWindow } from "./Utils";
export type EngineAuth = {
    token: string;
} | {
    apiKey: string;
};
type DisconnectInfo = {
    code: GameWsCloseCode;
    reason: string;
};
type TimeoutOrUndefined = ReturnType<typeof setTimeout> | undefined;
export declare class Engine {
    ws?: WebSocket;
    serverURL: string;
    getAuth: () => Promise<EngineAuth>;
    spaceId: string;
    clientUid?: string;
    debugOverrideServer?: string;
    debugOverrideHttpServer?: string;
    private started;
    private startTime;
    _connected: boolean;
    private connectionInitTime;
    private gotFirstMessage;
    private sizeOfNextLargeMessage;
    private sizeOfLargestMessageReceived;
    private _sendQ;
    private numMoveEventsBuffered;
    private transactionManager;
    private connectionFailedTimeout;
    private uploadLogTimeout;
    private uploadLogTimeoutLong;
    private lastSignOfLife;
    private abortConnectionAttempt;
    private lastSuccessfulFetch;
    _bufferedAmounts: SlidingWindow;
    private latencies;
    _timeSpentDisconnected: SlidingWindow;
    _eventCountsSinceOpen: {
        [event: string]: number;
    };
    _closeCounts: {
        [code: number]: number;
    };
    private connectMetrics;
    private readonly userIdForABTest;
    private preRefreshDcData;
    private connectionId;
    onevent(_e: ServerClientEvent): void;
    onconnect(): void;
    ondisconnect(_code?: number, _reason?: string): void;
    onmetric(_metricName: string, _metricValue: unknown): void;
    subscriptionHook(): void;
    constructor(spaceId: string, getAuth: () => Promise<EngineAuth>, overrideServer?: string, overrideHttpServer?: string);
    private saveUnloadDcState;
    private loadUnloadDcState;
    private clearUnloadDcState;
    start(): void;
    stop(disconnectInfo?: DisconnectInfo): void;
    private get isOnline();
    private getAuthWithAbort;
    private createConnection;
    private destroyConnection;
    get isReconnectScheduled(): boolean;
    get reconnectionAttempts(): number;
    private reconnectTimeout;
    private _reconnectionAttempts;
    private cleanUpAndQueueReconnect;
    private wantsToEnter;
    private tempInitInfo?;
    private tempSpawnToken?;
    private tempTargetId?;
    queueOrExecuteEnter(info?: PlayerInitInfo, spawnToken?: string, targetId?: string): void;
    exit(useTxn?: boolean): void | Promise<unknown>;
    private processEvent;
    private _lastActionSentAt;
    sendAction(action: ClientServerActionAction, bypass: boolean, createTxnId: true, txnId: undefined, txnTimeout?: number): Promise<unknown>;
    sendAction(action: ClientServerActionAction, bypass?: boolean, createTxnId?: false, txnId?: number, txnTimeout?: number): void;
    sendAction(action: ClientServerActionAction, bypass?: boolean, createTxnId?: boolean, txnId?: number, txnTimeout?: number): Promise<unknown> | void;
    private recordHeartbeatTime;
    _heartbeatInterval: TimeoutOrUndefined;
    private _lastRegularHeartbeatSent;
    private _lastBackupHeartbeatSent;
    private sendBackupHeartbeat;
    startHeartbeat(): void;
    stopHeartbeat(): void;
    private _byteTrackerInterval;
    private _bytesSentSinceConnect;
    private _bytesReceivedSinceConnect;
    private _lastBytesSent;
    private _lastBytesReceived;
    startByteTracker(): void;
    stopByteTracker(): void;
    private CONNECT_INTENT_POST_INTERVAL;
    private connectIntentInterval;
    private startRecordingIntentToConnect;
    private stopRecordingIntentToConnect;
    private trackRefreshFixedConnectionIssue;
    LOG_THRESH_MS: number;
    private uninterruptedLastFullSyncTime;
    private hasEverFullyConnected;
    private disconnectedStartTime;
    private dcLogTimeout;
    logDisconnectionStart(): void;
    logInitialSyncComplete(isPartialSubscribe: boolean): void;
    resetDisconnectionTracking(): void;
    queueDebugUpload(): void;
    private lastSuspendCheck;
    private suspendCheckInterval;
    private lastSuspendDate;
    checkAndHandleSuspend(): void;
    startSuspendCheck(): void;
    stopSuspendCheck(): void;
    getBaseMetricsInfo(): {
        serverUrl: string;
        connectionId: string;
    };
    private getGameServerUrl;
    getMetrics(): {
        connected: boolean;
        latency: import("./Utils").SlidingWindowMetrics;
        reconnects: {
            recentAttempts: number;
            timeSpentDisconnectedMs: import("./Utils").SlidingWindowMetrics;
        };
        bufferedAmount: import("./Utils").SlidingWindowMetrics;
        bytesSentSinceConnect: number;
        bytesReceivedSinceConnect: number;
        eventCountsSinceOpen: {
            [event: string]: number;
        };
        closeCodeCount: {
            [code: number]: number;
        };
    };
    redirectToProdIfOnProdServer(): void;
}
export {};
